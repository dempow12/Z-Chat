<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Z Chat</title>
    
    <!-- Google Fonts - Inter: Optimized for performance by preconnecting -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Marked.js for Markdown parsing: Loaded synchronously as it's critical for initial render -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <!-- Highlight.js for code syntax highlighting: Styles and script loaded for immediate effect -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- Custom Styles -->
    <style>
        /* --- CSS Variables for Theming --- */
        /* Defines color palette for dark and light modes, making theme switching easy */
        :root {
            --bg-dark-primary: #0D1117;
            --bg-dark-secondary: #161B22;
            --border-color: #30363D;
            --text-primary: #C9D1D9;
            --text-secondary: #8B949E;
            --accent-primary: #58A6FF;
            --accent-secondary: #3FB950;
            --accent-dream: #A371F7; /* Kept for potential future use or consistency */
            --user-message-bg: #21262D;
            --ai-message-bg: #161B22;
            --error-color: #F85149;
            --glow-color: rgba(88, 166, 255, 0.5);
            --dream-glow-color: rgba(163, 113, 247, 0.5); /* Kept for potential future use */
            --mic-glow-color: rgba(248, 81, 73, 0.7); /* Kept for potential future use */
            --loading-spinner-color: var(--accent-primary);
        }

        /* Light mode overrides for the CSS variables */
        .light-mode {
            --bg-dark-primary: #FFFFFF;
            --bg-dark-secondary: #F6F8FA;
            --border-color: #D0D7DE;
            --text-primary: #1F2328;
            --text-secondary: #57606A;
            --user-message-bg: #DDF4FF;
            --ai-message-bg: #FFFFFF;
        }

        /* --- Base Styles --- */
        /* Universal box-sizing for consistent layout, and reset margins/paddings */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Full viewport height for body and html, prevent unwanted scrolling */
        html, body {
            height: 100%;
            overflow: hidden; 
        }

        /* Main body styling: font, background, text color, flexbox for centering, and smooth transitions */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark-primary);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.3s ease;
        }
        
        /* --- App Layout --- */
        /* Flex container for the entire application (sidebar + chat area) */
        #app-layout {
            display: flex;
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden; 
        }

        /* --- Sidebar Styles --- */
        /* Defines the sidebar's width, background, border, and flex properties */
        #sidebar {
            width: 280px;
            background-color: var(--bg-dark-secondary);
            border-left: 1px solid var(--border-color); /* RTL: border-left for visual separation */
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease; /* For smooth mobile sidebar toggle */
            flex-shrink: 0; /* Prevents sidebar from shrinking */
            z-index: 101; /* Ensures it's above other content on mobile */
        }

        /* Header section within the sidebar */
        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Styling for the "New Chat" button in the sidebar header */
        .sidebar-header button {
            width: 100%;
            padding: 10px;
            background-color: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
        }

        .sidebar-header button:hover {
            background-color: #3b82f6; /* Slightly darker blue on hover */
        }
        
        /* General styling for sidebar sections (e.g., Pinned Memories) */
        .sidebar-section {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-section h3 {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        /* Styling for the main conversation list */
        #conversation-list {
            list-style: none;
            padding: 8px;
            flex-grow: 1; /* Allows it to take available vertical space */
            overflow-y: auto; /* Enables scrolling for many conversations */
        }

        /* Styling for individual conversation list items */
        #conversation-list li {
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis; /* Truncates long titles with ellipses */
            margin-bottom: 4px;
            transition: background-color 0.2s;
            position: relative;
        }

        #conversation-list li:hover {
            background-color: var(--user-message-bg);
        }

        #conversation-list li.active {
            background-color: var(--accent-primary);
            color: white;
        }

        /* Styling for the Pinned Memories list */
        #pinned-memories-list {
            list-style: none;
            padding: 0;
            max-height: 200px; /* Limits height to make it scrollable if many memories */
            overflow-y: auto;
        }

        #pinned-memories-list li {
            padding: 8px 12px;
            border-radius: 6px;
            background-color: var(--user-message-bg);
            margin-bottom: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #pinned-memories-list li:hover {
            background-color: var(--border-color);
        }

        /* Style for the unpin button within a pinned memory item */
        #pinned-memories-list li .unpin-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.8em;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s;
            flex-shrink: 0;
            margin-right: 8px; /* Space between text and button */
        }

        #pinned-memories-list li:hover .unpin-btn {
            opacity: 1; /* Show on hover */
        }

        /* --- Chat Container --- */
        /* Main chat area, takes remaining space, flex column for header, messages, and input */
        #chat-container {
            flex-grow: 1;
            min-width: 0; /* Allows content to shrink on smaller screens */
            background-color: var(--bg-dark-secondary);
            display: flex;
            flex-direction: column;
            overflow: hidden; 
            transition: background-color 0.3s ease, border-color 0.3s ease;
            position: relative;
        }

        /* --- Canvas Container --- */
        #canvas-container {
            flex-grow: 1;
            min-width: 0;
            background-color: var(--bg-dark-secondary);
            display: none; /* Hidden by default */
            flex-direction: column;
            overflow: hidden;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            position: relative;
        }
        #canvas-container.active {
            display: flex; /* Show when active */
        }

        #canvas-editor {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Canvas toolbar for adding blocks */
        .canvas-toolbar {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
            background-color: rgba(13, 17, 23, 0.7);
            backdrop-filter: blur(10px);
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-shrink: 0;
        }
        .canvas-toolbar button {
            padding: 8px 15px;
            background-color: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }
        .canvas-toolbar button:hover {
            background-color: #3b82f6;
        }
        .canvas-toolbar button.secondary {
            background-color: var(--user-message-bg);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        .canvas-toolbar button.secondary:hover {
            background-color: var(--border-color);
        }

        /* Individual Canvas Blocks */
        .canvas-block {
            background-color: var(--ai-message-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            position: relative;
            animation: fadeIn 0.4s ease-out;
            min-height: 100px; /* Ensure blocks have a minimum height */
        }
        .canvas-block:hover .block-actions {
            opacity: 1;
        }
        .canvas-block.focused {
            border-color: var(--accent-primary);
            box-shadow: 0 0 8px var(--glow-color);
        }

        /* Actions for individual blocks (move, delete, AI) */
        .block-actions {
            position: absolute;
            top: 8px;
            left: 8px; /* RTL: Position on the left */
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 5;
        }
        .block-actions button {
            background: var(--bg-dark-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 6px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .block-actions button:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        .block-actions .ai-block-action {
            background-color: var(--accent-dream);
            color: white;
            border-color: var(--accent-dream);
        }
        .block-actions .ai-block-action:hover {
            background-color: #8a4edb; /* Darker dream color */
            border-color: #8a4edb;
        }


        /* Text Block */
        .text-block textarea {
            width: 100%;
            background: none;
            border: none;
            outline: none;
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            line-height: 1.6;
            resize: vertical;
            min-height: 50px;
            padding: 0;
        }
        .text-block textarea::placeholder {
            color: var(--text-secondary);
        }
        .text-block .markdown-toolbar {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        .text-block .markdown-toolbar button {
            background: var(--bg-dark-primary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
        }
        .text-block .markdown-toolbar button:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }


        /* Code Block */
        .code-block .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .code-block .code-header select {
            background-color: var(--bg-dark-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .code-block pre {
            background-color: #010409;
            border-radius: 8px;
            padding: 16px;
            margin: 0; /* Override default margin */
            overflow-x: auto;
            border: 1px solid var(--border-color);
            position: relative;
        }
        .code-block code {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
            display: block; /* Ensure code block fills pre */
        }
        .code-block textarea { /* For editable code blocks */
            width: 100%;
            background: #010409;
            border: 1px solid var(--border-color);
            outline: none;
            color: var(--text-primary);
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.9em;
            line-height: 1.5;
            resize: vertical;
            min-height: 100px;
            padding: 10px;
            border-radius: 8px;
        }
        .code-block .copy-code-btn {
            position: absolute;
            top: 8px;
            left: 8px;
            background-color: var(--user-message-bg);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 6px;
            cursor: pointer;
            opacity: 1; /* Always visible for canvas code blocks */
            transition: none;
        }
        .code-block .code-output {
            background-color: #0d1117;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            color: var(--text-primary);
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.85em;
            min-height: 50px;
            overflow-x: auto;
            white-space: pre-wrap; /* Preserve whitespace and wrap lines */
            word-break: break-all; /* Break long words */
        }


        /* Image Block */
        .image-block {
            display: flex;
            flex-direction: column; /* Allow content to stack */
            justify-content: center;
            align-items: center;
            min-height: 100px;
            background-color: var(--user-message-bg);
            padding: 15px; /* Add padding for image content */
        }
        .image-block img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            object-fit: contain;
            margin-bottom: 10px; /* Space below image */
        }
        .image-block .image-upload-area {
            width: 100%;
            height: 150px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            cursor: pointer;
            transition: border-color 0.2s;
        }
        .image-block .image-upload-area:hover {
            border-color: var(--accent-primary);
        }
        .image-block .image-upload-area input {
            display: none;
        }
        .image-block .remove-image-btn {
            position: absolute;
            top: 0;
            right: 0;
            background-color: var(--error-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .image-block .generate-image-prompt {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-dark-primary);
            color: var(--text-primary);
            margin-top: 10px;
            resize: vertical;
            min-height: 40px;
        }
        .image-block .generate-image-btn {
            padding: 8px 15px;
            background-color: var(--accent-dream);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
            margin-top: 10px;
            width: 100%;
        }
        .image-block .generate-image-btn:hover {
            background-color: #8a4edb;
        }


        /* --- Header Styles --- */
        /* Chat header with logo, title, and action buttons */
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-dark-secondary);
            flex-shrink: 0; /* Prevents header from shrinking */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        
        .header-left, .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo { 
            width: 32px; 
            height: 32px; 
        }

        .logo svg { 
            width: 100%; 
            height: 100%; 
        }
        
        /* Keyframe animation for the logo's gradient color change */
        @keyframes gradient-animation {
            0% { --color-stop-1: #58A6FF; --color-stop-2: #3FB950; }
            50% { --color-stop-1: #3FB950; --color-stop-2: #A371F7; }
            100% { --color-stop-1: #58A6FF; --color-stop-2: #3FB950; }
        }

        #logo-gradient-stop-1 { 
            stop-color: var(--color-stop-1); 
        }

        #logo-gradient-stop-2 { 
            stop-color: var(--color-stop-2); 
        }

        .animated-logo { 
            animation: gradient-animation 10s ease infinite; 
        }

        /* Styling for the main chat title, using text-fill-color for gradient effect */
        header h1 {
            font-size: 1.4rem;
            font-weight: 700;
            color: transparent; 
            background: linear-gradient(45deg, var(--color-stop-1), var(--color-stop-2));
            -webkit-background-clip: text; 
            background-clip: text;
        }
        
        /* General styling for header buttons */
        .header-btn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            width: 36px;
            height: 36px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .header-btn:hover { 
            border-color: var(--accent-primary); 
            color: var(--accent-primary); 
        }

        /* --- Chat Messages Area --- */
        /* Container for all chat bubbles, scrollable */
        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #chat-messages.active {
            display: flex;
        }
        #chat-messages:not(.active) {
            display: none; /* Hide when not active */
        }
        
        /* Custom Scrollbar for Chat Messages (Webkit browsers) */
        #chat-messages::-webkit-scrollbar { 
            width: 8px; 
        }

        #chat-messages::-webkit-scrollbar-track { 
            background: transparent; 
        }

        #chat-messages::-webkit-scrollbar-thumb {
            background-color: var(--border-color);
            border-radius: 10px;
            border: 2px solid var(--bg-dark-secondary); 
        }

        /* --- Individual Message Styles --- */
        /* Base style for both user and AI messages */
        .message {
            display: flex;
            gap: 12px;
            max-width: 90%; 
            animation: fadeIn 0.4s ease-out; 
            position: relative; 
        }
        
        /* Fade-in animation for new messages */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Avatar styling for messages */
        .message .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; 
            font-weight: 600;
        }
        
        /* Wrapper for message content and action buttons */
        .message-content-wrapper { 
            position: relative; 
            flex-grow: 1; 
        }

        /* Styling for the actual message text bubble */
        .message-content {
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.6;
            word-wrap: break-word; /* Ensures long words wrap */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        /* Specific styles for AI messages */
        .ai-message { 
            align-self: flex-start; 
        }

        .ai-message .avatar { 
            background: linear-gradient(45deg, var(--accent-primary), #1F6FEB); 
            color: white; 
        }

        .ai-message .message-content {
            background-color: var(--ai-message-bg);
            border: 1px solid var(--border-color);
            border-top-left-radius: 4px; /* Rounded corners with a flat top-left */
        }
        
        /* Specific styles for user messages */
        .user-message { 
            align-self: flex-end; 
            flex-direction: row-reverse; /* Puts avatar on the right for RTL */
        }

        .user-message .avatar { 
            background-color: var(--accent-secondary); 
            color: #0D1117; 
        }

        .user-message .message-content {
            background-color: var(--user-message-bg);
            border: 1px solid var(--border-color);
            border-top-right-radius: 4px; /* Rounded corners with a flat top-right */
        }
        
        /* --- Chat Input Form --- */
        /* Wrapper for the input form, with translucent background and blur effect */
        #chat-form-wrapper {
            padding: 12px 16px;
            border-top: 1px solid var(--border-color);
            background-color: rgba(13, 17, 23, 0.7); 
            backdrop-filter: blur(10px); 
            flex-shrink: 0;
            transition: border-color 0.3s ease;
        }

        .light-mode #chat-form-wrapper { 
            background-color: rgba(246, 248, 250, 0.7); 
        }
        
        /* Styling for the chat input form itself */
        #chat-form {
            display: flex;
            align-items: flex-end; 
            gap: 10px;
            background-color: var(--bg-dark-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 8px;
            transition: all 0.2s;
            position: relative;
        }

        /* Focus state for the chat input form */
        #chat-form:focus-within { 
            border-color: var(--accent-primary); 
            box-shadow: 0 0 10px var(--glow-color); 
        }
        
        /* Styling for the message input textarea */
        #prompt-input {
            width: 100%;
            background: none;
            border: none;
            outline: none;
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            resize: none; 
            max-height: 150px;
            line-height: 1.5;
            padding: 8px;
            transition: color 0.3s ease;
        }
        
        /* Styling for the send message button */
        #send-button {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background-color: var(--accent-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            flex-shrink: 0; 
        }

        #send-button:disabled { 
            background-color: var(--border-color); 
            cursor: not-allowed; 
        }

        /* --- Message Actions (Copy, Regenerate, Edit, TTS, Pin) --- */
        /* Container for action buttons that appear on message hover */
        .message-actions {
            position: absolute;
            display: flex;
            gap: 6px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none; 
            bottom: -15px; 
        }

        .user-message .message-actions { 
            left: 0; 
        }

        .ai-message .message-actions { 
            right: 0; 
        }
        
        /* Show actions on hover over the message content wrapper */
        .message-content-wrapper:hover .message-actions { 
            opacity: 1; 
            transform: translateY(-5px); 
            pointer-events: all; 
        }
        
        /* Styling for individual action buttons */
        .action-btn {
            background: var(--bg-dark-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 6px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-btn:hover { 
            color: var(--text-primary); 
            border-color: var(--accent-primary); 
        }
        .action-btn.pin-btn.pinned {
            color: var(--accent-primary); /* Color when pinned */
            border-color: var(--accent-primary);
        }

        /* --- Modals (Settings, Confirm) --- */
        /* Overlay for modals, covers the entire screen */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease; 
        }

        .modal-overlay.visible { 
            display: flex; 
        }

        /* Content area of the modal */
        .modal-content {
            background-color: var(--bg-dark-secondary);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 500px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        /* Footer for modal buttons */
        .modal-footer { 
            margin-top: 24px; 
            display: flex; 
            justify-content: flex-end; 
            gap: 12px; 
        }

        .modal-footer button { 
            border: none; 
            padding: 8px 16px; 
            border-radius: 6px; 
            cursor: pointer; 
        }

        .modal-footer .save-btn { 
            background-color: var(--accent-primary); 
            color: white; 
        }

        .modal-footer .cancel-btn { 
            background-color: var(--border-color); 
            color: var(--text-primary); 
        }

        /* --- Context Menu (for Conversations) --- */
        /* Floating context menu for conversation list items */
        #context-menu {
            position: fixed;
            z-index: 1001;
            width: 160px;
            background: var(--bg-dark-primary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 8px;
            display: none;
        }

        .context-menu-item { 
            padding: 8px 12px; 
            cursor: pointer; 
            border-radius: 4px; 
        }

        .context-menu-item:hover { 
            background-color: var(--user-message-bg); 
        }

        .context-menu-item.delete { 
            color: var(--error-color); 
        }

        .context-menu-item.delete:hover { 
            background-color: rgba(248, 81, 73, 0.1); 
        }

        /* --- Drag & Drop Overlay --- */
        /* Overlay that appears when dragging files over the chat area */
        #drag-drop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(88, 166, 255, 0.1);
            border: 2px dashed var(--accent-primary);
            display: none; 
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--accent-primary);
            pointer-events: none; 
            z-index: 50;
        }

        #drag-drop-overlay.visible { 
            display: flex; 
        }

        /* --- Toast Notification --- */
        /* Small, temporary notification at the bottom of the screen */
        #toast-notification {
            position: fixed;
            bottom: -100px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--accent-secondary);
            color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 2000;
            transition: bottom 0.5s ease;
        }

        #toast-notification.show { 
            bottom: 20px; 
        }
        
        /* --- Image Preview in Input Area --- */
        /* Container for the image preview thumbnail */
        #image-preview-container { 
            padding: 0 8px 8px; 
            display: none; 
        }

        .image-preview { 
            position: relative; 
            display: inline-block; 
        }

        .image-preview img { 
            max-width: 100px; 
            max-height: 100px; 
            border-radius: 8px; 
            border: 1px solid var(--border-color); 
            object-fit: contain;
        }

        /* Button to remove the image preview */
        .remove-image-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: var(--error-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* --- Responsive Styles (Mobile First Approach) --- */
        /* Styles applied when screen width is 850px or less */
        @media (max-width: 850px) {
            #app-layout {
                overflow: hidden; 
            }

            #sidebar {
                position: fixed;
                top: 0;
                right: 0; /* For RTL, sidebar slides from the right */
                bottom: 0;
                height: 100%;
                transform: translateX(100%); /* Hidden off-screen by default */
                z-index: 1001;
                border-left: none; 
                border-right: 1px solid var(--border-color); /* Add border to the exposed side */
            }

            #app-layout.sidebar-open #sidebar {
                transform: translateX(0); /* Slide sidebar into view */
            }

            /* Overlay that appears when sidebar is open on mobile, to click outside and close */
            #mobile-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
                z-index: 1000;
                display: none; 
            }

            #app-layout.sidebar-open #mobile-overlay {
                display: block; 
            }
            
            .message {
                max-width: 95%; /* Adjust message width for smaller screens */
            }

            #chat-messages {
                padding: 12px; /* Reduce padding for chat messages */
            }

            header h1 {
                font-size: 1.2rem; /* Smaller header title on mobile */
            }
        }

        /* --- Utility Styles --- */
        /* Hide scrollbars for a cleaner UI (Webkit and Firefox) */
        #conversation-list::-webkit-scrollbar,
        #prompt-input::-webkit-scrollbar,
        #pinned-memories-list::-webkit-scrollbar,
        #canvas-editor::-webkit-scrollbar { 
            display: none; 
        }
        #conversation-list, #prompt-input, #pinned-memories-list, #canvas-editor { 
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none; /* Firefox */
        }
        
        /* Blinking cursor animation for AI typing indicator */
        .blinking-cursor { 
            animation: blink 1s step-end infinite; 
            display: inline-block; 
            width: 2px; 
            height: 1em; 
            background-color: var(--text-primary); 
            margin-right: 4px; 
        }

        @keyframes blink { 
            from, to { background-color: transparent } 
            50% { background-color: var(--text-primary); } 
        }

        /* Styling for the "Stop Generating" button */
        #stop-generating-btn { 
            position: absolute; 
            bottom: 120px; 
            left: 50%; 
            transform: translateX(-50%); 
            padding: 8px 16px; 
            background-color: var(--bg-dark-primary); 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            color: var(--text-primary); 
            cursor: pointer; 
            display: none; 
            z-index: 10; 
            transition: all 0.2s ease; 
        }

        #stop-generating-btn:hover { 
            border-color: var(--error-color); 
            color: var(--error-color); 
        }

        /* Code block styling (from Highlight.js) */
        .message-content pre { 
            background-color: #010409; 
            border-radius: 8px; 
            padding: 16px; 
            margin: 12px 0; 
            overflow-x: auto; 
            border: 1px solid var(--border-color); 
            position: relative; 
        }

        .light-mode .message-content pre { 
            background-color: #F6F8FA; 
            border-color: #D0D7DE; 
        }

        /* Copy code button within code blocks */
        .message-content pre .copy-code-btn { 
            position: absolute; 
            top: 8px; 
            left: 8px; /* RTL: Position on the left */
            background-color: var(--user-message-bg); 
            border: 1px solid var(--border-color); 
            color: var(--text-secondary); 
            padding: 4px 8px; 
            border-radius: 6px; 
            cursor: pointer; 
            opacity: 1; /* Always visible for canvas code blocks */
            transition: none;
        }

        .message-content pre:hover .copy-code-btn { 
            opacity: 1; 
        }

        /* Font for code blocks */
        .message-content code { 
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; 
            font-size: 0.9em; 
        }

        /* Styling for inline code snippets */
        .message-content p > code { 
            background-color: rgba(139, 148, 158, 0.2); 
            padding: 2px 4px; 
            border-radius: 4px; 
        }

        .light-mode .message-content p > code { 
            background-color: rgba(87, 96, 106, 0.1); 
        }

        /* Styling for settings modal fields */
        .settings-field { 
            margin-bottom: 16px; 
        }

        .settings-field label { 
            display: block; 
            margin-bottom: 8px; 
            color: var(--text-secondary); 
            font-size: 0.9rem; 
        }

        .settings-field select, .settings-field textarea { 
            width: 100%; 
            padding: 8px; 
            border-radius: 6px; 
            border: 1px solid var(--border-color); 
            background-color: var(--bg-dark-primary); 
            color: var(--text-primary); 
        }

        .settings-field textarea { 
            min-height: 120px; 
            resize: vertical; 
        }

        /* Styling for chat suggestions container and buttons */
        #suggestions-container { 
            padding: 0 24px 12px; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 12px; 
            justify-content: center; 
        }

        .suggestion-btn { 
            padding: 10px 16px; 
            font-size: 0.9rem; 
            background-color: rgba(48, 54, 61, 0.5); 
            border: 1px solid var(--border-color); 
            color: var(--text-secondary); 
            border-radius: 20px; 
            cursor: pointer; 
            transition: all 0.2s ease; 
            backdrop-filter: blur(5px); 
        }

        /* Loading Spinner */
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: var(--loading-spinner-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
            display: block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="app-layout">
        <aside id="sidebar">
            <div class="sidebar-header">
                <button id="new-chat-btn-sidebar" type="button">محادثة جديدة +</button>
                <!-- New Canvas Button -->
                <button id="new-canvas-btn-sidebar" type="button" style="margin-top: 8px; background-color: var(--accent-dream);">لوحة كانفاس جديدة +</button>
            </div>
            <!-- New section for Pinned Memories -->
            <div class="sidebar-section">
                <h3>الذكريات المثبتة</h3>
                <ul id="pinned-memories-list" role="list">
                    <!-- Pinned memories will be rendered here -->
                </ul>
            </div>
            <!-- Section for Canvas Documents -->
            <div class="sidebar-section">
                <h3>لوحات الكانفاس</h3>
                <ul id="canvas-document-list" role="list">
                    <!-- Canvas documents will be rendered here -->
                </ul>
            </div>
            <ul id="conversation-list" role="list"></ul>
        </aside>

        <!-- Mobile overlay for closing sidebar by tapping outside -->
        <div id="mobile-overlay"></div>

        <div id="chat-container" class="active"> <!-- Chat container is active by default -->
            <!-- Drag and drop overlay for image uploads -->
            <div id="drag-drop-overlay">أفلت الصورة هنا</div>

            <header role="banner">
                <div class="header-left animated-logo">
                    <!-- Sidebar toggle button for mobile -->
                    <button id="sidebar-toggle" class="header-btn" type="button" title="فتح/إغلاق الشريط الجانبي">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                    </button>
                    <div class="logo" role="img" aria-label="Z Chat Logo">
                           <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M16.8829 7.11713C16.8829 3.72714 13.9358 1 10.2914 1C6.64708 1 4.11719 3.72714 4.11719 7.11713C4.11719 10.5071 10.2914 15.4542 10.2914 23C10.2914 15.4542 16.8829 10.5071 16.8829 7.11713Z" stroke="url(#paint0_linear_1_2)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <defs>
                                    <linearGradient id="paint0_linear_1_2" x1="10.5" y1="1" x2="10.5" y2="23" gradientUnits="userSpaceOnUse">
                                        <stop id="logo-gradient-stop-1" />
                                        <stop id="logo-gradient-stop-2" offset="1"/>
                                    </linearGradient>
                                </defs>
                           </svg>
                    </div>
                    <h1 class="animated-logo">Z Chat</h1>
                </div>
                <div class="header-right">
                    <!-- New Toggle View Button -->
                    <button id="toggle-view-btn" class="header-btn" type="button" title="تبديل العرض">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-columns">
                            <path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>
                        </svg>
                    </button>
                    <!-- Settings button -->
                    <button id="settings-btn" class="header-btn" type="button" title="الإعدادات">
                           <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                    </button>
                    <!-- Download chat button -->
                    <button id="download-chat-btn" type="button" title="تنزيل المحادثة">
                           <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                    </button>
                    <!-- Theme toggle button -->
                    <button id="theme-toggle-btn" type="button" title="تغيير المظهر">
                           <svg id="theme-icon-sun" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                    </button>
                </div>
            </header>
    
            <main id="chat-messages" role="main" aria-live="polite"></main>
            
            <div id="suggestions-container"></div>
    
            <button id="stop-generating-btn" type="button">إيقاف التوليد</button>
    
            <div id="chat-form-wrapper">
                <div id="image-preview-container"></div>
                
                <form id="chat-form" aria-label="أرسل رسالة إلى Z Chat">
                    <button id="attachment-btn" type="button" class="header-btn" title="إرفاق صورة" style="width: 40px; height: 40px;">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
                    </button>
                    <input type="file" id="image-upload-input" accept="image/*" style="display: none;" aria-label="تحميل صورة">
                    
                    <textarea id="prompt-input" placeholder="أرسل رسالة..." rows="1" aria-label="أدخل رسالتك هنا"></textarea>
                    
                    <button id="send-button" type="submit" title="إرسال">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/>
                        </svg>
                    </button>
                </form>
            </div>
        </div>

        <div id="canvas-container">
            <header role="banner" style="border-bottom: none;">
                <div class="header-left">
                    <h1 id="canvas-title-display" class="animated-logo">لوحة كانفاس جديدة</h1>
                </div>
                <div class="header-right">
                    <button id="rename-canvas-btn" class="header-btn" type="button" title="إعادة تسمية الكانفاس">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                    </button>
                    <button id="delete-canvas-btn" class="header-btn" type="button" title="حذف الكانفاس">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                    </button>
                </div>
            </header>
            <div id="canvas-editor">
                <!-- Canvas blocks will be rendered here -->
            </div>
            <div class="canvas-toolbar">
                <button id="add-text-block-btn" type="button">أضف نص</button>
                <button id="add-code-block-btn" type="button">أضف كود</button>
                <button id="add-image-block-btn" type="button">أضف صورة</button>
                <button id="ask-ai-canvas-btn" type="button" class="secondary">اسأل الذكاء الاصطناعي</button>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="settings-modal-title">
        <div class="modal-content">
            <h2 id="settings-modal-title">الإعدادات</h2>
            <div class="settings-field">
                <label for="model-select">اختر نموذج الذكاء الاصطناعي:</label>
                <select id="model-select">
                    <!-- Only one option now, renamed to "Z-Chat Demo" -->
                    <option value="anthropic/claude-3-haiku">Z-Chat Demo</option>
                </select>
            </div>
            <div class="settings-field">
                <label for="system-prompt-textarea">موجه النظام (شخصية الذكاء الاصطناعي):</label>
                <textarea id="system-prompt-textarea"></textarea>
            </div>
            <div class="modal-footer">
                <button id="save-settings-btn" class="save-btn" type="button">حفظ وإغلاق</button>
            </div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirm-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="confirm-title">
        <div class="modal-content">
            <h2 id="confirm-title"></h2>
            <p id="confirm-message" style="margin-top: 10px;"></p>
            <div class="modal-footer">
                <button id="confirm-cancel-btn" class="cancel-btn" type="button">إلغاء</button>
                <button id="confirm-ok-btn" class="save-btn" type="button">تأكيد</button>
            </div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast-notification" aria-live="assertive" aria-atomic="true"></div>
    
    <!-- Context Menu for Conversation List Items -->
    <div id="context-menu" role="menu">
        <div class="context-menu-item" id="rename-conv-btn" role="menuitem">إعادة تسمية</div>
        <div class="context-menu-item delete" id="delete-conv-btn" role="menuitem">حذف</div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            // Grouping all DOM element queries for better organization and potential performance.
            // Using `const` for elements that don't change.
            const allDOMElements = {
                appLayout: document.getElementById('app-layout'),
                sidebar: document.getElementById('sidebar'),
                sidebarToggle: document.getElementById('sidebar-toggle'),
                mobileOverlay: document.getElementById('mobile-overlay'),
                conversationList: document.getElementById('conversation-list'),
                newChatBtnSidebar: document.getElementById('new-chat-btn-sidebar'),
                chatContainer: document.getElementById('chat-container'),
                chatMessages: document.getElementById('chat-messages'),
                chatForm: document.getElementById('chat-form'),
                promptInput: document.getElementById('prompt-input'),
                sendButton: document.getElementById('send-button'),
                suggestionsContainer: document.getElementById('suggestions-container'),
                themeToggleBtn: document.getElementById('theme-toggle-btn'),
                stopGeneratingBtn: document.getElementById('stop-generating-btn'),
                downloadChatBtn: document.getElementById('download-chat-btn'),
                settingsBtn: document.getElementById('settings-btn'),
                settingsModal: document.getElementById('settings-modal'),
                saveSettingsBtn: document.getElementById('save-settings-btn'),
                modelSelect: document.getElementById('model-select'),
                systemPromptTextarea: document.getElementById('system-prompt-textarea'),
                attachmentBtn: document.getElementById('attachment-btn'),
                imageUploadInput: document.getElementById('image-upload-input'),
                imagePreviewContainer: document.getElementById('image-preview-container'),
                toast: document.getElementById('toast-notification'),
                dragDropOverlay: document.getElementById('drag-drop-overlay'),
                confirmModal: document.getElementById('confirm-modal'),
                confirmTitle: document.getElementById('confirm-title'),
                confirmMessage: document.getElementById('confirm-message'),
                confirmOkBtn: document.getElementById('confirm-ok-btn'),
                confirmCancelBtn: document.getElementById('confirm-cancel-btn'),
                contextMenu: document.getElementById('context-menu'),
                renameConvBtn: document.getElementById('rename-conv-btn'),
                deleteConvBtn: document.getElementById('delete-conv-btn'),
                pinnedMemoriesList: document.getElementById('pinned-memories-list'),

                // New Canvas Elements
                newCanvasBtnSidebar: document.getElementById('new-canvas-btn-sidebar'),
                canvasDocumentList: document.getElementById('canvas-document-list'),
                canvasContainer: document.getElementById('canvas-container'),
                canvasEditor: document.getElementById('canvas-editor'),
                canvasToolbar: document.querySelector('.canvas-toolbar'),
                addTextBlockBtn: document.getElementById('add-text-block-btn'),
                addCodeBlockBtn: document.getElementById('add-code-block-btn'),
                addImageBlockBtn: document.getElementById('add-image-block-btn'),
                askAiCanvasBtn: document.getElementById('ask-ai-canvas-btn'),
                toggleViewBtn: document.getElementById('toggle-view-btn'),
                canvasTitleDisplay: document.getElementById('canvas-title-display'),
                renameCanvasBtn: document.getElementById('rename-canvas-btn'),
                deleteCanvasBtn: document.getElementById('delete-canvas-btn')
            };

            // --- API & Model Configuration ---
            // Using `let` for variables that will be reassigned.
            // User-provided API key for OpenRouter
            const API_KEY = "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";
            const TEXT_AI_URL = "https://openrouter.ai/api/v1/chat/completions";
            // Image generation still uses Google's Imagen API, which is handled differently by Canvas.
            // The `key=${API_KEY}` part will be automatically filled by Canvas when API_KEY is empty.
            // For OpenRouter, the API_KEY is used in the Authorization header.
            const IMAGE_AI_URL = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=`; 
            // Set default model to Claude 3 Haiku for "Z-Chat Demo"
            let MODEL = localStorage.getItem('z_chat_model') || "anthropic/claude-3-haiku"; 
            allDOMElements.modelSelect.value = MODEL;

            // --- State Variables ---
            let conversations = {};
            let currentConversationId = null;
            let abortController = new AbortController(); // Manages API request cancellation
            let attachedImage = null; // Stores the base64 URL of the attached image
            let initialSystemPrompt = localStorage.getItem('z_chat_system_prompt') || `أنت مساعد ذكاء اصطناعي اسمك "Z Chat". مهمتك هي الرد على المستخدمين بلغة عربية فصيحة وطبيعية. يجب أن تكون جميع ردودك باللغة العربية فقط. كن ودودًا ومساعدًا ومبدعًا وأجب على السؤال مباشرة وبشكل واضح. لا تذكر أبدًا أنك ذكاء اصطناعي.`;
            allDOMElements.systemPromptTextarea.value = initialSystemPrompt;
            let contextMenuTargetId = null; // Stores the ID of the conversation clicked on for context menu

            // State for Pinned Memories
            let pinnedMemories = JSON.parse(localStorage.getItem('z_chat_pinned_memories') || '[]');

            // New State for Canvas Documents
            let canvasDocuments = {};
            let currentCanvasId = null;
            let activeView = 'chat'; // 'chat' or 'canvas'
            let focusedCanvasBlockId = null; // Tracks the currently focused canvas block for AI interaction

            // Supported code languages for syntax highlighting
            const supportedCodeLanguages = [
                "javascript", "python", "html", "css", "java", "csharp", "php", "ruby", "typescript", "json", "xml", "markdown"
            ];

            // Constant for maximum input characters to prevent token limit errors
            // Reduced to a more conservative value for free tiers on OpenRouter
            const MAX_TOTAL_INPUT_CHARS = 800; // Further reduced for safer token limits

            /**
             * Helper to calculate content length for token estimation.
             * @param {string|Array} content - The message content.
             * @returns {number} The estimated character length.
             */
            const getContentLength = (content) => {
                if (typeof content === 'string') {
                    return content.length;
                } else if (Array.isArray(content)) {
                    return content.reduce((acc, part) => acc + (part.text ? part.text.length : 0), 0);
                }
                return 0;
            };

            /**
             * Creates and appends a message element to the chat interface.
             * @param {string} sender - 'user' or 'ai'
             * @param {string} text - The message content (can be Markdown for AI).
             * @param {boolean} isError - True if it's an error message.
             * @param {string} messageId - Optional: A specific ID for the message.
             * @returns {HTMLElement} The created message element.
             */
            const createMessageElement = (sender, text = "", isError = false, messageId = `msg-${Date.now()}`) => {
                const messageElement = document.createElement('div');
                messageElement.id = messageId;
                messageElement.classList.add('message', `${sender}-message`);
                if (isError) messageElement.classList.add('error-message');

                const avatarChar = sender === 'ai' ? 'Z' : 'أ';
                // Use DOMPurify if integrating user-generated content directly with marked.parse for security
                const formattedText = isError ? text.replace(/\n/g, '<br>') : marked.parse(text);

                // Check if this message is already pinned
                const isPinned = pinnedMemories.some(mem => mem.originalMessageId === messageId);

                messageElement.innerHTML = `
                    <div class="avatar" role="img" aria-label="${sender === 'ai' ? 'Z Chat Avatar' : 'User Avatar'}">${avatarChar}</div>
                    <div class="message-content-wrapper">
                        <div class="message-content" data-raw-text="${text}">${formattedText}</div>
                        <div class="message-actions">
                            ${sender === 'ai' && !isError && text ? `
                                <button class="action-btn tts-btn" title="قراءة النص" type="button">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                                </button>
                                <button class="action-btn copy-btn" title="نسخ" type="button">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                                </button>
                                <button class="action-btn regenerate-btn" title="إعادة توليد الإجابة" type="button">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"></path><path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path><path d="M21 22v-6h-6"></path><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path></svg>
                                </button>
                            ` : ''}
                            ${sender === 'user' ? `
                                <button class="action-btn edit-btn" title="تعديل" type="button">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                                </button>
                            ` : ''}
                            <!-- New Pin button -->
                            <button class="action-btn pin-btn ${isPinned ? 'pinned' : ''}" title="${isPinned ? 'إلغاء التثبيت' : 'تثبيت الرسالة'}" type="button" data-message-id="${messageId}" data-conversation-id="${currentConversationId}">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-star">
                                    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                                </svg>
                            </button>
                        </div>
                    </div>
                `;
                allDOMElements.chatMessages.appendChild(messageElement);
                if (text) addCodeCopyButtons(messageElement);
                scrollToBottom();
                return messageElement;
            };

            /**
             * Adds copy-to-clipboard buttons to code blocks within a given container.
             * @param {HTMLElement} container - The DOM element to search for code blocks.
             */
            const addCodeCopyButtons = (container = document) => {
                container.querySelectorAll('.message-content pre').forEach(pre => {
                    // Check if a copy button already exists to prevent duplicates
                    if (pre.querySelector('.copy-code-btn')) return;
                    
                    const btn = document.createElement('button');
                    btn.className = 'copy-code-btn';
                    btn.innerText = 'نسخ';
                    btn.type = 'button'; // Specify type for buttons
                    btn.onclick = () => copyToClipboard(pre.querySelector('code').innerText);
                    pre.appendChild(btn);
                });
            };

            /**
             * Handles the submission of a user message.
             * @param {string} messageText - The text content of the user's message.
             */
            const submitMessage = (messageText) => {
                if (!messageText.trim() && !attachedImage) return;

                const userMessageId = `msg-${Date.now()}`;
                createMessageElement('user', messageText, false, userMessageId); // Pass messageId
                allDOMElements.promptInput.value = '';
                allDOMElements.promptInput.style.height = 'auto'; // Reset textarea height
                allDOMElements.suggestionsContainer.style.display = 'none'; // Hide suggestions

                // Construct message payload for API
                const userMessagePayload = {
                    role: "user",
                    content: messageText // OpenRouter expects string content for simple text
                };

                // Add image data to payload if an image is attached
                if (attachedImage) {
                    // OpenRouter vision models expect content as an array of objects
                    userMessagePayload.content = [
                        { type: "text", text: messageText },
                        { type: "image_url", image_url: { url: attachedImage } }
                    ];
                    MODEL = "openai/gpt-4o"; // Force vision model for image input
                    allDOMElements.modelSelect.value = MODEL;
                }
                
                // Update conversation history and save
                conversations[currentConversationId].history.push(userMessagePayload);
                saveAllData(); 
                clearImagePreview(); // Clear image preview after sending

                // Fetch AI response
                fetchAiResponse();
            };
            
            /**
             * Fetches a response from the AI model.
             * @param {boolean} isRegeneration - True if the request is for regenerating a response.
             */
            async function fetchAiResponse(isRegeneration = false) {
                // Handle regeneration: remove last AI message from history and DOM
                if (isRegeneration) {
                    const lastMsg = conversations[currentConversationId].history.at(-1);
                    if (lastMsg?.role === 'assistant') {
                        conversations[currentConversationId].history.pop();
                        // Remove the last AI message element from the DOM
                        const allAiMessages = allDOMElements.chatMessages.querySelectorAll('.ai-message');
                        if (allAiMessages.length > 0) {
                            allAiMessages[allAiMessages.length - 1].remove();
                        }
                    }
                }

                if (!API_KEY) {
                    createMessageElement('ai', 'خطأ: مفتاح API غير موجود. يرجى إدخال مفتاح OpenRouter API في الإعدادات.', true);
                    return;
                }

                setLoadingState(true); // Show loading indicators
                abortController = new AbortController(); // Create a new AbortController for the current request
                
                const aiMessageId = `msg-${Date.now()}`; // Generate ID for AI message
                const aiMessageElement = createMessageElement('ai', "", false, aiMessageId); // Pass messageId
                const aiMessageContentDiv = aiMessageElement.querySelector('.message-content');
                const cursorSpan = document.createElement('span');
                cursorSpan.className = 'blinking-cursor';
                aiMessageContentDiv.appendChild(cursorSpan); // Add blinking cursor

                let fullResponse = ""; // Accumulate streaming response

                try {
                    // Construct messages array for API call
                    let messagesToSend = [];
                    let currentInputChars = 0;
                    let historyTrimmed = false;

                    // Add initial system prompt
                    messagesToSend.push({ role: "system", content: initialSystemPrompt });
                    currentInputChars += getContentLength(initialSystemPrompt);

                    // Add pinned memories as a system message
                    if (pinnedMemories.length > 0) {
                        const memoryText = pinnedMemories.map(m => `- ${m.text}`).join('\n');
                        const memoryMessage = { 
                            role: "system", 
                            content: `تذكر المعلومات الهامة التالية من محادثاتك السابقة:\n${memoryText}` 
                        };
                        messagesToSend.push(memoryMessage);
                        currentInputChars += getContentLength(memoryMessage.content);
                    }

                    // Add conversation history from newest to oldest, trimming if necessary
                    const conversationHistoryToProcess = conversations[currentConversationId].history.slice(1); // Skip initial system prompt
                    const reversedHistory = [...conversationHistoryToProcess].reverse(); // Create a reversed copy

                    for (const msg of reversedHistory) {
                        let msgContentLength = getContentLength(msg.content);
                        // Add a small buffer for role and structure overhead (e.g., 20 chars per message)
                        if (currentInputChars + msgContentLength + 20 < MAX_TOTAL_INPUT_CHARS) {
                            messagesToSend.push(msg);
                            currentInputChars += msgContentLength + 20;
                        } else {
                            historyTrimmed = true;
                            break;
                        }
                    }

                    // Reverse the messagesToSend (excluding initial system prompts) to get chronological order
                    // Keep system messages at the beginning
                    const systemMessages = messagesToSend.filter(msg => msg.role === 'system');
                    const userAndAssistantMessages = messagesToSend.filter(msg => msg.role !== 'system').reverse(); // Reverse back to chronological

                    messagesToSend = systemMessages.concat(userAndAssistantMessages);

                    if (historyTrimmed) {
                        showToast('تم تقصير سجل المحادثة لإرساله إلى الذكاء الاصطناعي لتجنب تجاوز الحد الأقصى للرموز.');
                    }

                    const response = await fetch(TEXT_AI_URL, { 
                        method: 'POST',
                        headers: { 
                            'Authorization': `Bearer ${API_KEY}`, // Use API key in Authorization header for OpenRouter
                            'Content-Type': 'application/json' 
                        },
                        body: JSON.stringify({ 
                            model: MODEL, 
                            messages: messagesToSend, 
                            stream: true, // Request streaming response
                            max_tokens: 400 // Reduced max tokens to avoid credit issues
                        }),
                        signal: abortController.signal, // Link abort controller to fetch
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `HTTP error! Status: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break; // End of stream

                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n').filter(line => line.trim().startsWith('data:'));
                        
                        for (const line of lines) {
                            const dataStr = line.substring(6); 
                            if (dataStr === '[DONE]') break; 
                            
                            try {
                                const data = JSON.parse(dataStr);
                                if (data.choices && data.choices.length > 0 && data.choices[0].delta && data.choices[0].delta.content) {
                                    const contentChunk = data.choices[0].delta.content;
                                    fullResponse += contentChunk;
                                    aiMessageContentDiv.insertBefore(document.createTextNode(contentChunk), cursorSpan);
                                    scrollToBottom();
                                }
                            } catch (e) { 
                                console.warn("Failed to parse JSON chunk:", e);
                            }
                        }
                    }
                    
                    // Final rendering of the complete response with Markdown and highlighting
                    aiMessageContentDiv.innerHTML = marked.parse(fullResponse);
                    aiMessageContentDiv.dataset.rawText = fullResponse; // Store raw text for copy/edit
                    aiMessageElement.querySelectorAll('pre code').forEach(hljs.highlightElement); // Highlight code blocks
                    addCodeCopyButtons(aiMessageElement); // Add copy buttons to new code blocks

                    // Save the complete AI response to history
                    conversations[currentConversationId].history.push({ role: "assistant", content: fullResponse });
                    
                    // Auto-generate title for new chats after first AI response
                    if (conversations[currentConversationId].history.length === 3) { // System, User, AI
                        await generateConversationTitle(fullResponse); // Await title generation
                    } else {
                        saveAllData(); 
                    }

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        aiMessageElement.classList.add('error-message');
                        aiMessageContentDiv.innerText = `عذراً، حدث خطأ: ${error.message}`;
                        console.error("AI Response Error:", error);
                    } else {
                        aiMessageContentDiv.innerHTML = marked.parse(fullResponse + " (توقف)");
                        aiMessageContentDiv.dataset.rawText = fullResponse;
                    }
                } finally {
                    setLoadingState(false); // Hide loading indicators
                    cursorSpan.remove(); // Remove blinking cursor
                }
            }
            
            /**
             * Generates a short title for the conversation based on the AI's first response.
             * @param {string} aiResponse - The first AI response to use for title generation.
             */
            async function generateConversationTitle(aiResponse) {
                const titlePrompt = `بناءً على الرد التالي، اقترح عنواناً قصيراً جداً (3-5 كلمات) باللغة العربية لهذه المحادثة. أجب بالعنوان فقط بدون أي مقدمات:\n\n"${aiResponse.substring(0, 150)}..."`;
                
                try {
                    const response = await fetch(TEXT_AI_URL, { 
                        method: 'POST',
                        headers: { 
                            'Authorization': `Bearer ${API_KEY}`, 
                            'Content-Type': 'application/json' 
                        },
                        body: JSON.stringify({
                            model: "anthropic/claude-3-haiku", // Use Claude 3 Haiku for title generation
                            messages: [{role: "user", content: titlePrompt}],
                            max_tokens: 100 // Smaller max_tokens for titles
                        }),
                    });

                    if (!response.ok) {
                        console.warn("Failed to fetch title:", response.statusText);
                        saveAllData(); 
                        return; 
                    }

                    const data = await response.json();
                    const newTitle = data.choices[0].message.content.trim().replace(/["']/g, ''); 
                    
                    if (newTitle) {
                        conversations[currentConversationId].title = newTitle;
                        saveAllData(); 
                        renderConversationList(); // Update sidebar with new title
                    }
                } catch (error) {
                    console.error("Failed to generate title:", error);
                    saveAllData(); 
                }
            }

            // --- Utility & Helper Functions ---

            /**
             * Sets the loading state of the UI elements.
             * @param {boolean} isLoading - True to show loading indicators, false to hide.
             * @param {string} targetBlockId - Optional: The ID of the canvas block that is loading.
             */
            const setLoadingState = (isLoading, targetBlockId = null) => {
                // Only affect chat input/send button if in chat view
                if (activeView === 'chat') {
                    allDOMElements.sendButton.disabled = isLoading;
                    allDOMElements.promptInput.disabled = isLoading;
                }
                // Stop generating button is global
                allDOMElements.stopGeneratingBtn.style.display = isLoading ? 'block' : 'none';

                // Disable canvas toolbar buttons if AI is generating for canvas
                if (activeView === 'canvas') {
                    allDOMElements.addTextBlockBtn.disabled = isLoading;
                    allDOMElements.addCodeBlockBtn.disabled = isLoading;
                    allDOMElements.addImageBlockBtn.disabled = isLoading;
                    allDOMElements.askAiCanvasBtn.disabled = isLoading;

                    // Show/hide loading spinner in specific block if targetBlockId is provided
                    if (targetBlockId) {
                        const blockElement = document.getElementById(targetBlockId);
                        if (blockElement) {
                            let spinner = blockElement.querySelector('.loading-spinner');
                            if (isLoading) {
                                if (!spinner) {
                                    spinner = document.createElement('div');
                                    spinner.className = 'loading-spinner';
                                    blockElement.appendChild(spinner);
                                }
                            } else {
                                if (spinner) {
                                    spinner.remove();
                                }
                            }
                        }
                    }
                }
            };

            /**
             * Copies text to the clipboard and shows a toast notification.
             * @param {string} text - The text to copy.
             */
            function copyToClipboard(text) {
                document.execCommand('copy', false, text); // Use execCommand for clipboard due to iframe restrictions
                showToast('تم النسخ بنجاح!');
            }

            /**
             * Uses SpeechSynthesis to read out the given text.
             * @param {string} text - The text to speak.
             * @param {HTMLElement} button - The button element that triggered the speech (for styling).
             */
            function speak(text, button) {
                // If speech is already in progress, stop it
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                    // Remove 'playing' class from all TTS buttons
                    document.querySelectorAll('.tts-btn.playing').forEach(btn => btn.classList.remove('playing'));
                    // If the same button was clicked to stop, just return
                    if (button.classList.contains('playing')) return;
                }
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'ar-SA'; // Set language to Arabic (Saudi Arabia)
                utterance.onstart = () => button.classList.add('playing'); // Add playing class when speech starts
                utterance.onend = () => button.classList.remove('playing'); // Remove playing class when speech ends
                speechSynthesis.speak(utterance);
            }

            /**
             * Displays a transient toast notification.
             * @param {string} message - The message to display in the toast.
             */
            function showToast(message) {
                allDOMElements.toast.textContent = message;
                allDOMElements.toast.classList.add('show');
                setTimeout(() => {
                    allDOMElements.toast.classList.remove('show');
                }, 2500); // Hide after 2.5 seconds
            }

            /**
             * Scrolls the chat messages container to the bottom.
             */
            const scrollToBottom = () => {
                if (activeView === 'chat') {
                    allDOMElements.chatMessages.scrollTop = allDOMElements.chatMessages.scrollHeight;
                } else if (activeView === 'canvas') {
                    allDOMElements.canvasEditor.scrollTop = allDOMElements.canvasEditor.scrollHeight;
                }
            };

            /**
             * Displays predefined chat suggestions.
             */
            const showSuggestions = () => {
                const suggestions = ["اشرح مفهوم الحوسبة الكمومية", "اكتب قصة قصيرة عن مستكشف فضاء", "ما هي أفضل طريقة لتعلم لغة بايثون؟", "اقترح خطة سفر لمدة أسبوع في اليابان"];
                allDOMElements.suggestionsContainer.innerHTML = ''; // Clear previous suggestions
                suggestions.forEach(text => {
                    const btn = document.createElement('button');
                    btn.className = 'suggestion-btn';
                    btn.textContent = text;
                    btn.type = 'button'; // Explicitly set type to button
                    btn.onclick = () => submitMessage(text); // Attach click handler
                    allDOMElements.suggestionsContainer.appendChild(btn);
                });
                allDOMElements.suggestionsContainer.style.display = 'flex'; // Show the container
            };
            
            // --- Conversation Management ---

            /**
             * Saves all application data (conversations, canvas documents, pinned memories) to localStorage.
             */
            const saveAllData = () => {
                localStorage.setItem('z_chat_conversations', JSON.stringify(conversations));
                localStorage.setItem('z_chat_current_conversation', currentConversationId);
                localStorage.setItem('z_chat_pinned_memories', JSON.stringify(pinnedMemories));
                localStorage.setItem('z_chat_canvas_documents', JSON.stringify(canvasDocuments)); // Save canvas documents
                localStorage.setItem('z_chat_current_canvas', currentCanvasId); // Save current canvas
                localStorage.setItem('z_chat_active_view', activeView); // Save active view
            };

            /**
             * Loads all application data from localStorage and initializes the UI.
             */
            const loadAllData = () => {
                // Load Conversations
                const savedConversations = localStorage.getItem('z_chat_conversations');
                if (savedConversations) {
                    conversations = JSON.parse(savedConversations);
                    currentConversationId = localStorage.getItem('z_chat_current_conversation');
                }
                // If no conversations exist or current one is invalid, start a new chat
                if (!currentConversationId || !conversations[currentConversationId]) {
                    startNewChat(); 
                } else {
                    loadConversation(currentConversationId); // Load active chat
                }
                renderConversationList(); // Render chat list

                // Load Pinned Memories
                pinnedMemories = JSON.parse(localStorage.getItem('z_chat_pinned_memories') || '[]');
                renderPinnedMemories();

                // Load Canvas Documents
                const savedCanvas = localStorage.getItem('z_chat_canvas_documents');
                if (savedCanvas) {
                    canvasDocuments = JSON.parse(savedCanvas);
                    currentCanvasId = localStorage.getItem('z_chat_current_canvas');
                }
                // If no canvas exists or current one is invalid, ensure currentCanvasId is null
                if (!currentCanvasId || !canvasDocuments[currentCanvasId]) {
                    currentCanvasId = null; // Ensure it's explicitly null if no valid canvas
                } else {
                    loadCanvas(currentCanvasId); // Load active canvas
                }
                renderCanvasList(); // Render canvas list

                // Load active view
                activeView = localStorage.getItem('z_chat_active_view') || 'chat';
                switchView(activeView); // Set the correct view
            };

            /**
             * Renders the list of conversations in the sidebar.
             */
            const renderConversationList = () => {
                allDOMElements.conversationList.innerHTML = ''; // Clear existing list
                // Sort conversations by ID (which implicitly sorts by creation time)
                const conversationIds = Object.keys(conversations);
                if (conversationIds.length === 0) {
                    // Hide conversation list section if empty
                    allDOMElements.conversationList.parentElement.style.display = 'none';
                    return;
                } else {
                    allDOMElements.conversationList.parentElement.style.display = 'block';
                }

                conversationIds.sort((a,b) => b.split('-')[1] - a.split('-')[1]).forEach(id => {
                    const conv = conversations[id];
                    const li = document.createElement('li');
                    li.textContent = conv.title;
                    li.dataset.id = id;
                    // Add 'active' class if it's the current conversation
                    if (id === currentConversationId && activeView === 'chat') li.classList.add('active');
                    
                    // Attach event listeners for loading and context menu
                    li.addEventListener('click', () => {
                        switchView('chat'); // Switch to chat view
                        loadConversation(id);
                    });
                    li.addEventListener('contextmenu', (e) => {
                        e.preventDefault(); // Prevent default browser context menu
                        contextMenuTargetId = id; // Store ID for context menu actions
                        // Position context menu
                        allDOMElements.contextMenu.style.top = `${e.clientY}px`;
                        allDOMElements.contextMenu.style.left = `${e.clientX}px`;
                        allDOMElements.contextMenu.style.display = 'block';
                    });
                    
                    allDOMElements.conversationList.appendChild(li);
                });
            };
            
            /**
             * Loads and displays the messages for a specific conversation.
             * @param {string} id - The ID of the conversation to load.
             */
            const loadConversation = (id) => {
                // If there's an ongoing AI response, abort it before switching conversations
                if (abortController) {
                    abortController.abort();
                    setLoadingState(false);
                }

                currentConversationId = id;
                allDOMElements.chatMessages.innerHTML = ''; // Clear current chat messages
                
                // Render messages, skipping the initial system prompt in history
                conversations[id].history.slice(1).forEach(msg => {
                    let text = '';
                    // Handle both text-only and multimodal (text + image) messages
                    if (Array.isArray(msg.content)) {
                        text = msg.content.find(p => p.type === 'text')?.text || '[صورة]';
                    } else {
                        text = msg.content;
                    }
                    createMessageElement(msg.role, text, false, msg.id); // Pass message ID when loading
                });

                renderConversationList(); // Re-render to update active state
                // Show/hide suggestions based on conversation length
                if (conversations[id].history.length > 2) { // More than system + first AI welcome msg
                    allDOMElements.suggestionsContainer.style.display = 'none';
                } else {
                    showSuggestions();
                }
                saveAllData(); 
                
                // Close sidebar on mobile after selecting a conversation
                if (window.innerWidth < 850) { 
                    allDOMElements.appLayout.classList.remove('sidebar-open');
                }
            };
            
            /**
             * Starts a new, empty chat conversation.
             */
            const startNewChat = () => {
                // If an AI response is in progress, abort it
                if (abortController) {
                    abortController.abort();
                    setLoadingState(false);
                }

                const newId = `conv-${Date.now()}`; // Unique ID based on timestamp
                const newTitle = `محادثة جديدة`;
                conversations[newId] = {
                    id: newId,
                    title: newTitle,
                    history: [{ role: "system", content: initialSystemPrompt }] // Include system prompt
                };
                
                allDOMElements.chatMessages.innerHTML = ''; // Clear chat area
                const welcomeMessage = 'مرحباً بك في Z Chat. أنا مساعدك الذكي، كيف يمكنني خدمتك اليوم؟';
                const welcomeMessageId = `msg-${Date.now()}`;
                createMessageElement('ai', welcomeMessage, false, welcomeMessageId);
                conversations[newId].history.push({ role: "assistant", content: welcomeMessage, id: welcomeMessageId }); // Add welcome message to history with ID
                
                loadConversation(newId); // Load the newly created conversation
                showSuggestions(); // Show suggestions for new chats
                switchView('chat'); // Ensure we are in chat view
            };

            // --- Pinned Memories Management ---

            /**
             * Adds or removes a message from pinned memories.
             * @param {string} messageId - The ID of the message to pin/unpin.
             * @param {string} conversationId - The ID of the conversation the message belongs to.
             * @param {HTMLElement} pinButton - The button element that triggered the action.
             */
            const togglePinMemory = (messageId, conversationId, pinButton) => {
                const existingMemoryIndex = pinnedMemories.findIndex(mem => mem.originalMessageId === messageId);

                if (existingMemoryIndex > -1) {
                    // Memory exists, unpin it
                    pinnedMemories.splice(existingMemoryIndex, 1);
                    if (pinButton) { // Button might not exist if unpinning from sidebar
                        pinButton.classList.remove('pinned');
                        pinButton.title = 'تثبيت الرسالة';
                    }
                    showToast('تم إلغاء تثبيت الرسالة.');
                } else {
                    // Memory does not exist, pin it
                    const conversation = conversations[conversationId];
                    if (!conversation) return;

                    // Find the message in the conversation history
                    const messageInHistory = conversation.history.find(msg => msg.id === messageId);
                    let messageText = '';
                    if (messageInHistory) {
                        if (Array.isArray(messageInHistory.content)) {
                            messageText = messageInHistory.content.find(p => p.type === 'text')?.text || '[صورة]';
                        } else {
                            messageText = messageInHistory.content;
                        }
                    } else {
                        // Fallback if message not found in history (e.g., welcome message not explicitly added with ID initially)
                        const messageElement = document.getElementById(messageId);
                        if (messageElement) {
                            messageText = messageElement.querySelector('.message-content').dataset.rawText || messageElement.innerText;
                        }
                    }

                    if (messageText) {
                        pinnedMemories.push({
                            id: `pin-${Date.now()}`,
                            text: messageText,
                            timestamp: Date.now(),
                            originalMessageId: messageId,
                            originalConversationId: conversationId
                        });
                        if (pinButton) { // Button might not exist if unpinning from sidebar
                            pinButton.classList.add('pinned');
                            pinButton.title = 'تم تثبيت الرسالة';
                        }
                        showToast('تم تثبيت الرسالة بنجاح!');
                    } else {
                        showToast('لا يمكن تثبيت رسالة فارغة.');
                    }
                }
                saveAllData();
                renderPinnedMemories(); // Update the pinned memories list in the sidebar
            };

            /**
             * Renders the list of pinned memories in the sidebar.
             */
            const renderPinnedMemories = () => {
                allDOMElements.pinnedMemoriesList.innerHTML = ''; // Clear existing list
                if (pinnedMemories.length === 0) {
                    allDOMElements.pinnedMemoriesList.parentElement.style.display = 'none';
                    return;
                } else {
                    allDOMElements.pinnedMemoriesList.parentElement.style.display = 'block';
                }

                pinnedMemories.forEach(mem => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span>${mem.text.substring(0, 50)}${mem.text.length > 50 ? '...' : ''}</span>
                        <button class="unpin-btn" type="button" title="إلغاء التثبيت">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </button>
                    `;
                    li.querySelector('.unpin-btn').addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent li click event
                        togglePinMemory(mem.originalMessageId, mem.originalConversationId, document.querySelector(`[data-message-id="${mem.originalMessageId}"]`));
                    });
                    allDOMElements.pinnedMemoriesList.appendChild(li);
                });
            };

            // --- Canvas Document Management ---

            /**
             * Renders the list of Canvas documents in the sidebar.
             */
            const renderCanvasList = () => {
                allDOMElements.canvasDocumentList.innerHTML = '';
                const canvasIds = Object.keys(canvasDocuments);
                if (canvasIds.length === 0) {
                    allDOMElements.canvasDocumentList.parentElement.style.display = 'none';
                    return;
                } else {
                    allDOMElements.canvasDocumentList.parentElement.style.display = 'block';
                }

                canvasIds.sort((a,b) => b.split('-')[1] - a.split('-')[1]).forEach(id => {
                    const canvasDoc = canvasDocuments[id];
                    const li = document.createElement('li');
                    li.textContent = canvasDoc.title;
                    li.dataset.id = id;
                    if (id === currentCanvasId && activeView === 'canvas') li.classList.add('active');

                    li.addEventListener('click', () => {
                        switchView('canvas');
                        loadCanvas(id);
                    });
                    // Add context menu for canvas documents similar to conversations if needed
                    allDOMElements.canvasDocumentList.appendChild(li);
                });
            };

            /**
             * Creates a new empty Canvas document.
             */
            const createNewCanvas = () => {
                const newId = `canvas-${Date.now()}`;
                const newTitle = `لوحة كانفاس جديدة`;
                canvasDocuments[newId] = {
                    id: newId,
                    title: newTitle,
                    blocks: [] // Array to hold content blocks
                };
                currentCanvasId = newId; // Ensure currentCanvasId is set immediately
                loadCanvas(newId); // This will also call saveAllData and renderCanvasList
                switchView('canvas');
                showToast('تم إنشاء لوحة كانفاس جديدة.');
            };

            /**
             * Loads a specific Canvas document into the editor.
             * @param {string} id - The ID of the Canvas document to load.
             */
            const loadCanvas = (id) => {
                currentCanvasId = id;
                allDOMElements.canvasEditor.innerHTML = ''; // Clear current editor content
                const canvasDoc = canvasDocuments[id];
                if (!canvasDoc) {
                    console.error("Canvas document not found:", id);
                    // If canvas not found, reset currentCanvasId and create new if in canvas view
                    currentCanvasId = null; 
                    if (activeView === 'canvas') {
                        createNewCanvas(); // Create a new one to avoid empty state
                    }
                    return;
                }
                allDOMElements.canvasTitleDisplay.textContent = canvasDoc.title;

                canvasDoc.blocks.forEach(block => renderCanvasBlock(block));
                saveAllData();
                renderCanvasList(); // Update active state in sidebar
                scrollToBottom(); // Scroll to the end of the canvas
            };

            /**
             * Renders a single canvas block into the editor.
             * @param {object} block - The block object {id, type, content, language (for code), etc.}.
             */
            const renderCanvasBlock = (block) => {
                const blockElement = document.createElement('div');
                blockElement.id = block.id;
                blockElement.classList.add('canvas-block', `${block.type}-block`);

                // Add focus/blur listeners to track active block
                if (block.type === 'text' || block.type === 'code') {
                    blockElement.addEventListener('focusin', () => {
                        focusedCanvasBlockId = block.id;
                        blockElement.classList.add('focused');
                    });
                    blockElement.addEventListener('focusout', () => {
                        focusedCanvasBlockId = null;
                        blockElement.classList.remove('focused');
                    });
                } else if (block.type === 'image') {
                    // For image blocks, clicking anywhere in the block can set focus
                    blockElement.addEventListener('click', (e) => {
                        // Only set focus if not clicking on child buttons
                        if (!e.target.closest('.block-actions') && !e.target.closest('.remove-image-btn') && !e.target.closest('.generate-image-btn')) {
                            focusedCanvasBlockId = block.id;
                            blockElement.classList.add('focused');
                        }
                    });
                    // Clear focus if clicking outside the image block
                    document.addEventListener('click', (e) => {
                        if (!e.target.closest(`#${block.id}`) && focusedCanvasBlockId === block.id) {
                            focusedCanvasBlockId = null;
                            blockElement.classList.remove('focused');
                        }
                    });
                }


                let contentHTML = '';
                if (block.type === 'text') {
                    contentHTML = `
                        <div class="markdown-toolbar">
                            <button type="button" onclick="applyMarkdownToTextBlock('${block.id}', '# ')">H1</button>
                            <button type="button" onclick="applyMarkdownToTextBlock('${block.id}', '**')">B</button>
                            <button type="button" onclick="applyMarkdownToTextBlock('${block.id}', '*')">I</button>
                            <button type="button" onclick="applyMarkdownToTextBlock('${block.id}', '- ')">List</button>
                            <button type="button" onclick="applyMarkdownToTextBlock('${block.id}', '[]()')">Link</button>
                        </div>
                        <textarea placeholder="أدخل نصًا هنا..." oninput="this.style.height='auto'; this.style.height=(this.scrollHeight)+'px';" onblur="handleCanvasBlockUpdate('${block.id}', this.value)" dir="rtl">${block.content}</textarea>`;
                } else if (block.type === 'code') {
                    const languageOptions = supportedCodeLanguages.map(lang => 
                        `<option value="${lang}" ${block.language === lang ? 'selected' : ''}>${lang}</option>`
                    ).join('');

                    contentHTML = `
                        <div class="code-header">
                            <select onchange="updateCodeBlockLanguage('${block.id}', this.value)">
                                ${languageOptions}
                            </select>
                        </div>
                        <textarea placeholder="أدخل الكود هنا..." oninput="this.style.height='auto'; this.style.height=(this.scrollHeight)+'px';" onblur="handleCanvasBlockUpdate('${block.id}', this.value)" dir="ltr" style="text-align: left;">${block.content}</textarea>
                        <button class="action-btn" style="margin-top: 10px; width: auto; padding: 5px 10px;" onclick="runCodeBlock('${block.id}')">تشغيل الكود</button>
                        <div class="code-output" id="output-${block.id}"></div>
                        `;
                } else if (block.type === 'image') {
                    contentHTML = `
                        ${block.content ? `<img src="${block.content}" alt="صورة الكانفاس"/>
                            <button class="remove-image-btn" type="button" onclick="removeCanvasImage('${block.id}')">×</button>` :
                        `<div class="image-upload-area" onclick="document.getElementById('canvas-image-upload-${block.id}').click()">
                            <input type="file" id="canvas-image-upload-${block.id}" accept="image/*" onchange="handleCanvasImageUpload(event, '${block.id}')" style="display: none;">
                            <span>انقر أو اسحب صورة هنا</span>
                        </div>`}
                        <textarea class="generate-image-prompt" placeholder="وصف الصورة لتوليدها بالذكاء الاصطناعي..." onblur="updateImageBlockPrompt('${block.id}', this.value)" dir="rtl">${block.imagePrompt || ''}</textarea>
                        <button class="generate-image-btn" type="button" onclick="generateImageInBlock('${block.id}')">توليد صورة بالذكاء الاصطناعي</button>
                    `;
                }

                blockElement.innerHTML = `
                    <div class="block-actions">
                        <button type="button" title="تحريك لأعلى" onclick="moveCanvasBlock('${block.id}', 'up')">↑</button>
                        <button type="button" title="تحريك لأسفل" onclick="moveCanvasBlock('${block.id}', 'down')">↓</button>
                        <button type="button" title="حذف الكتلة" onclick="deleteCanvasBlock('${block.id}')">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    </div>
                    ${contentHTML}
                `;
                allDOMElements.canvasEditor.appendChild(blockElement);

                // Apply syntax highlighting after rendering if it's a code block
                if (block.type === 'code' && block.content) {
                    const codeElement = blockElement.querySelector('textarea');
                    if (codeElement) {
                        // Temporarily create a pre/code element for highlighting
                        const tempPre = document.createElement('pre');
                        const tempCode = document.createElement('code');
                        tempCode.className = `language-${block.language || 'plaintext'}`;
                        tempCode.textContent = block.content;
                        tempPre.appendChild(tempCode);
                        hljs.highlightElement(tempCode);
                        // Replace textarea with highlighted code
                        codeElement.replaceWith(tempPre);
                    }
                }

                // Auto-resize textarea after rendering
                if (block.type === 'text' || block.type === 'code') {
                    const textarea = blockElement.querySelector('textarea');
                    if (textarea) {
                        textarea.style.height = 'auto';
                        textarea.style.height = (textarea.scrollHeight) + 'px';
                    }
                }
            };

            // Global functions for inline event handlers in Canvas blocks
            window.handleCanvasBlockUpdate = (blockId, newContent) => {
                const canvasDoc = canvasDocuments[currentCanvasId];
                if (!canvasDoc) {
                    console.error("Canvas document not found during update:", currentCanvasId);
                    return;
                }
                const block = canvasDoc.blocks.find(b => b.id === blockId);
                if (block) {
                    block.content = newContent;
                    saveAllData();
                }
            };

            window.updateCodeBlockLanguage = (blockId, newLanguage) => {
                const canvasDoc = canvasDocuments[currentCanvasId];
                if (!canvasDoc) return;
                const block = canvasDoc.blocks.find(b => b.id === blockId);
                if (block && block.type === 'code') {
                    block.language = newLanguage;
                    saveAllData();
                    loadCanvas(currentCanvasId); // Re-render to apply new highlighting
                }
            };

            window.updateImageBlockPrompt = (blockId, newPrompt) => {
                const canvasDoc = canvasDocuments[currentCanvasId];
                if (!canvasDoc) return;
                const block = canvasDoc.blocks.find(b => b.id === blockId);
                if (block && block.type === 'image') {
                    block.imagePrompt = newPrompt;
                    saveAllData();
                }
            };

            window.handleCanvasImageUpload = (event, blockId) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const canvasDoc = canvasDocuments[currentCanvasId];
                        if (!canvasDoc) {
                            console.error("Canvas document not found during image upload:", currentCanvasId);
                            return;
                        }
                        const block = canvasDoc.blocks.find(b => b.id === blockId);
                        if (block) {
                            block.content = e.target.result;
                            saveAllData();
                            loadCanvas(currentCanvasId); // Re-render to show image
                        }
                    };
                    reader.readAsDataURL(file);
                } else {
                    showToast('الرجاء اختيار ملف صورة فقط.');
                }
            };

            window.removeCanvasImage = (blockId) => {
                const canvasDoc = canvasDocuments[currentCanvasId];
                if (!canvasDoc) {
                    console.error("Canvas document not found during image removal:", currentCanvasId);
                    return;
                }
                const block = canvasDoc.blocks.find(b => b.id === blockId);
                if (block) {
                    block.content = ''; // Clear image content
                    block.imagePrompt = ''; // Clear image prompt
                    saveAllData();
                    loadCanvas(currentCanvasId); // Re-render to show upload area
                }
            };

            window.applyMarkdownToTextBlock = (blockId, syntax) => {
                const blockElement = document.getElementById(blockId);
                const textarea = blockElement.querySelector('textarea');
                if (!textarea) return;

                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = textarea.value.substring(start, end);
                let newText = '';

                if (syntax === '# ') { // Heading 1
                    newText = `# ${selectedText}`;
                } else if (syntax === '**') { // Bold
                    newText = `**${selectedText}**`;
                } else if (syntax === '*') { // Italic
                    newText = `*${selectedText}*`;
                } else if (syntax === '- ') { // List item
                    newText = `- ${selectedText}`;
                } else if (syntax === '[]()') { // Link
                    const url = prompt('أدخل الرابط:');
                    if (url) {
                        newText = `[${selectedText || 'النص الرابط'}](${url})`;
                    } else {
                        newText = selectedText; // No change if no URL
                    }
                }

                textarea.value = textarea.value.substring(0, start) + newText + textarea.value.substring(end);
                handleCanvasBlockUpdate(blockId, textarea.value);
                textarea.focus();
                textarea.setSelectionRange(start + newText.length, start + newText.length); // Adjust cursor position
            };


            /**
             * Adds a new block to the current Canvas document.
             * @param {string} type - 'text', 'code', or 'image'.
             * @param {string} content - Initial content for the block.
             * @param {string} language - Initial language for code blocks.
             */
            const addCanvasBlock = (type, content = '', language = 'plaintext') => {
                let targetCanvasId = currentCanvasId;
                if (!targetCanvasId || !canvasDocuments[targetCanvasId]) {
                    // If no current canvas is selected or it's invalid, create a new one.
                    createNewCanvas(); // This will set currentCanvasId and update canvasDocuments.
                    targetCanvasId = currentCanvasId; // Get the newly set currentCanvasId
                }
                
                const canvasDoc = canvasDocuments[targetCanvasId]; // Now canvasDoc should be defined
                if (!canvasDoc) { // Double-check in case createNewCanvas failed or something unexpected
                    console.error("Failed to get a valid canvas document after creation attempt.");
                    showToast('حدث خطأ: لا يمكن إضافة الكتلة. حاول إنشاء لوحة كانفاس جديدة يدوياً.');
                    return;
                }

                const newBlock = {
                    id: `block-${Date.now()}`,
                    type: type,
                    content: content,
                    language: type === 'code' ? language : undefined, // Only for code blocks
                    imagePrompt: type === 'image' ? '' : undefined // Only for image blocks
                };
                canvasDoc.blocks.push(newBlock);
                saveAllData();
                renderCanvasBlock(newBlock); // Render the new block immediately
                scrollToBottom();
            };

            /**
             * Deletes a block from the current Canvas document.
             * @param {string} blockId - The ID of the block to delete.
             */
            window.deleteCanvasBlock = (blockId) => {
                showConfirmModal(
                    'تأكيد الحذف',
                    'هل أنت متأكد من رغبتك في حذف هذه الكتلة؟',
                    () => {
                        const canvasDoc = canvasDocuments[currentCanvasId];
                        if (!canvasDoc) {
                            console.error("Canvas document not found during block deletion:", currentCanvasId);
                            return;
                        }
                        canvasDoc.blocks = canvasDoc.blocks.filter(block => block.id !== blockId);
                        saveAllData();
                        document.getElementById(blockId)?.remove(); // Remove from DOM
                        showToast('تم حذف الكتلة.');
                    }
                );
            };

            /**
             * Moves a block up or down in the current Canvas document.
             * @param {string} blockId - The ID of the block to move.
             * @param {string} direction - 'up' or 'down'.
             */
            window.moveCanvasBlock = (blockId, direction) => {
                const canvasDoc = canvasDocuments[currentCanvasId];
                if (!canvasDoc) {
                    console.error("Canvas document not found during block move:", currentCanvasId);
                    return;
                }
                const index = canvasDoc.blocks.findIndex(block => block.id === blockId);

                if (index === -1) return;

                const newIndex = direction === 'up' ? index - 1 : index + 1;

                if (newIndex >= 0 && newIndex < canvasDoc.blocks.length) {
                    const [movedBlock] = canvasDoc.blocks.splice(index, 1);
                    canvasDoc.blocks.splice(newIndex, 0, movedBlock);
                    saveAllData();
                    loadCanvas(currentCanvasId); // Re-render the entire canvas to reflect order change
                }
            };

            /**
             * Renames the current Canvas document.
             */
            const renameCurrentCanvas = () => {
                if (!currentCanvasId || !canvasDocuments[currentCanvasId]) {
                    showToast('لا توجد لوحة كانفاس نشطة لإعادة تسميتها.');
                    return;
                }
                const oldTitle = canvasDocuments[currentCanvasId].title;
                const newTitle = prompt("أدخل الاسم الجديد للوحة الكانفاس:", oldTitle);
                if (newTitle && newTitle.trim() !== oldTitle) {
                    canvasDocuments[currentCanvasId].title = newTitle.trim();
                    saveAllData();
                    allDOMElements.canvasTitleDisplay.textContent = newTitle.trim();
                    renderCanvasList();
                    showToast('تمت إعادة تسمية لوحة الكانفاس بنجاح.');
                }
            };

            /**
             * Deletes the current Canvas document.
             */
            const deleteCurrentCanvas = () => {
                if (!currentCanvasId || !canvasDocuments[currentCanvasId]) {
                    showToast('لا توجد لوحة كانفاس نشطة لحذفها.');
                    return;
                }
                showConfirmModal(
                    'تأكيد الحذف',
                    `هل أنت متأكد من رغبتك في حذف لوحة الكانفاس "${canvasDocuments[currentCanvasId].title}"؟ لا يمكن التراجع عن هذا الإجراء.`,
                    () => {
                        delete canvasDocuments[currentCanvasId];
                        currentCanvasId = null; // Unset current canvas
                        saveAllData();
                        // Load the first available canvas, or create new if none
                        const firstCanvasId = Object.keys(canvasDocuments)[0];
                        if (firstCanvasId) {
                            loadCanvas(firstCanvasId);
                        } else {
                            allDOMElements.canvasEditor.innerHTML = ''; // Clear editor
                            allDOMElements.canvasTitleDisplay.textContent = 'لوحة كانفاس جديدة';
                            switchView('chat'); // Switch to chat view if no canvas is left
                        }
                        renderCanvasList();
                        showToast('تم حذف لوحة الكانفاس.');
                    }
                );
            };

            /**
             * Central function to ask AI for content within the Canvas.
             * It determines action based on focused block or generates new block.
             */
            const askAiForCanvasContent = async () => {
                let targetBlock = null;

                if (focusedCanvasBlockId) {
                    targetBlock = canvasDocuments[currentCanvasId]?.blocks.find(b => b.id === focusedCanvasBlockId);
                }

                let userPrompt = prompt("أدخل توجيهاتك للذكاء الاصطناعي:", "");
                if (!userPrompt) return;

                if (targetBlock && (targetBlock.type === 'text' || targetBlock.type === 'code')) {
                    // AI generates text/code into an existing block
                    await generateTextOrCodeInBlock(targetBlock.id, userPrompt);
                } else if (targetBlock && targetBlock.type === 'image') {
                    // AI generates an image into an existing image block
                    await generateImageInBlock(targetBlock.id, userPrompt);
                } else {
                    // No specific block focused, ask AI to generate new blocks
                    await generateNewCanvasBlocks(userPrompt);
                }
            };

            /**
             * Generates text or code into an existing canvas block.
             * @param {string} blockId - The ID of the text/code block.
             * @param {string} userPrompt - The user's prompt for AI generation.
             */
            const generateTextOrCodeInBlock = async (blockId, userPrompt) => {
                const block = canvasDocuments[currentCanvasId]?.blocks.find(b => b.id === blockId);
                if (!block || (block.type !== 'text' && block.type !== 'code')) {
                    showToast('الكتلة المحددة ليست كتلة نص أو كود.');
                    return;
                }

                setLoadingState(true, blockId);
                abortController = new AbortController();

                try {
                    const currentContent = block.content;
                    const messagesToSend = [
                        { role: "system", content: initialSystemPrompt },
                        { role: "user", content: `المحتوى الحالي للكتلة هو:\n\n${currentContent}\n\n بناءً على هذا المحتوى، قم بتوليد محتوى جديد أو توسيع المحتوى الحالي بناءً على طلب المستخدم. إذا كان الطلب يتعلق بكود برمجي، قم بتوليده ضمن ثلاث علامات اقتباس معكوسة مع تحديد اللغة. أجب مباشرة بالمحتوى الجديد أو المحدث.` },
                        { role: "user", content: userPrompt }
                    ];

                    // Calculate total input characters and trim if necessary
                    let totalInputChars = messagesToSend.reduce((acc, msg) => acc + getContentLength(msg.content), 0);

                    if (totalInputChars > MAX_TOTAL_INPUT_CHARS) {
                        const systemPromptChars = getContentLength(messagesToSend[0].content);
                        const userPromptChars = getContentLength(messages[2].content);
                        const availableCharsForBlockContent = MAX_TOTAL_INPUT_CHARS - systemPromptChars - userPromptChars - 100; // Buffer for roles, etc.

                        if (availableCharsForBlockContent > 0) {
                            messagesToSend[1].content = messagesToSend[1].content.substring(messagesToSend[1].content.length - availableCharsForBlockContent);
                            showToast('تم تقصير محتوى الكتلة لإرساله إلى الذكاء الاصطناعي لتجنب تجاوز الحد الأقصى للرموز.');
                        } else {
                            showToast('الطلب طويل جداً ولا يمكن معالجته. يرجى تقصير المحتوى أو التوجيه.');
                            setLoadingState(false, blockId);
                            return;
                        }
                    }

                    const response = await fetch(TEXT_AI_URL, {
                        method: 'POST',
                        headers: { 
                            'Authorization': `Bearer ${API_KEY}`, // Use API key in Authorization header
                            'Content-Type': 'application/json' 
                        },
                        body: JSON.stringify({ 
                            model: MODEL, 
                            messages: messagesToSend,
                            max_tokens: 400 // Reduced max tokens for generation
                        }),
                        signal: abortController.signal,
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `HTTP error! Status: ${response.status}`);
                    }

                    const data = await response.json();
                    const aiGeneratedContent = data.choices[0].message.content;

                    block.content = aiGeneratedContent; // Update block content
                    saveAllData();
                    loadCanvas(currentCanvasId); // Re-render to show updated content
                    showToast('تم تحديث الكتلة بالذكاء الاصطناعي.');

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        showToast(`خطأ في توليد الذكاء الاصطناعي: ${error.message}`);
                        console.error("AI Generation Error:", error);
                    } else {
                        showToast('تم إيقاف التوليد.');
                    }
                } finally {
                    setLoadingState(false, blockId);
                }
            };

            /**
             * Generates an image into an existing image block.
             * @param {string} blockId - The ID of the image block.
             * @param {string} userPrompt - The user's prompt for image generation.
             */
            window.generateImageInBlock = async (blockId, userPrompt = null) => {
                const block = canvasDocuments[currentCanvasId]?.blocks.find(b => b.id === blockId);
                if (!block || block.type !== 'image') {
                    showToast('الكتلة المحددة ليست كتلة صورة.');
                    return;
                }

                const promptText = userPrompt || block.imagePrompt;
                if (!promptText) {
                    showToast('الرجاء إدخال وصف للصورة لتوليدها.');
                    return;
                }

                setLoadingState(true, blockId);
                abortController = new AbortController();

                try {
                    const payload = { instances: { prompt: promptText }, parameters: { "sampleCount": 1} };
                    const response = await fetch(IMAGE_AI_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: abortController.signal,
                    });

                    const result = await response.json();
                    if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                        const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                        block.content = imageUrl; // Update image content
                        saveAllData();
                        loadCanvas(currentCanvasId); // Re-render to show new image
                        showToast('تم توليد الصورة بنجاح!');
                    } else {
                        throw new Error("فشل توليد الصورة أو الاستجابة غير متوقعة.");
                    }
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        showToast(`خطأ في توليد الصورة: ${error.message}`);
                        console.error("Image Generation Error:", error);
                    } else {
                        showToast('تم إيقاف توليد الصورة.');
                    }
                } finally {
                    setLoadingState(false, blockId);
                }
            };

            /**
             * Generates new text/code blocks based on a user prompt.
             * @param {string} userPrompt - The user's prompt for AI generation.
             */
            const generateNewCanvasBlocks = async (userPrompt) => {
                if (!currentCanvasId) {
                    createNewCanvas(); // Ensure a canvas exists
                }
                const canvasDoc = canvasDocuments[currentCanvasId];

                setLoadingState(true); // Global loading for new blocks
                abortController = new AbortController();

                try {
                    const currentCanvasContent = canvasDoc.blocks.map(block => {
                        if (block.type === 'text' || block.type === 'code') {
                            return block.content;
                        } else if (block.type === 'image' && block.content) {
                            return `[صورة: ${block.imagePrompt || 'صورة بدون وصف'}]`;
                        }
                        return '';
                    }).join('\n\n');

                    const messagesToSend = [
                        { role: "system", content: initialSystemPrompt },
                        { role: "user", content: `المحتوى الحالي للوحة الكانفاس هو:\n\n${currentCanvasContent}\n\n بناءً على هذا المحتوى، قم بتوليد محتوى جديد أو توسيع المحتوى الحالي بناءً على طلب المستخدم. يجب أن تكون إجابتك بتنسيق JSON، حيث يكون كل عنصر في المصفوفة كتلة من نوع "text" أو "code". لا تقم بتضمين أي مقدمات أو خاتمات، فقط مصفوفة JSON. مثال: [{"type": "text", "content": "محتوى نصي"}, {"type": "code", "content": "print('Hello')"}].` },
                        { role: "user", content: userPrompt }
                    ];

                    // Calculate total input characters and trim if necessary
                    let totalInputChars = messagesToSend.reduce((acc, msg) => acc + getContentLength(msg.content), 0);

                    if (totalInputChars > MAX_TOTAL_INPUT_CHARS) {
                        const systemPromptChars = getContentLength(messagesToSend[0].content);
                        const userPromptChars = getContentLength(messagesToSend[2].content);
                        const availableCharsForCanvasContent = MAX_TOTAL_INPUT_CHARS - systemPromptChars - userPromptChars - 100; // Buffer

                        if (availableCharsForCanvasContent > 0) {
                            messagesToSend[1].content = `المحتوى السابق للوحة الكانفاس (تم تقصيره):\n\n${messagesToSend[1].content.substring(messagesToSend[1].content.length - availableCharsForCanvasContent)}`;
                            showToast('تم تقصير محتوى لوحة الكانفاس لإرساله إلى الذكاء الاصطناعي لتجنب تجاوز الحد الأقصى للرموز.');
                        } else {
                            showToast('الطلب طويل جداً ولا يمكن معالجته. يرجى تقصير المحتوى أو التوجيه.');
                            setLoadingState(false);
                            return;
                        }
                    }

                    const response = await fetch(TEXT_AI_URL, {
                        method: 'POST',
                        headers: { 
                            'Authorization': `Bearer ${API_KEY}`, // Use API key in Authorization header
                            'Content-Type': 'application/json' 
                        },
                        body: JSON.stringify({ 
                            model: MODEL, 
                            messages: messagesToSend,
                            response_format: { type: "json_object" }, // Request JSON output
                            max_tokens: 500 // Limit max tokens for generation
                        }),
                        signal: abortController.signal,
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const aiGeneratedContent = JSON.parse(data.choices[0].message.content);

                    if (Array.isArray(aiGeneratedContent)) {
                        aiGeneratedContent.forEach(block => {
                            if (block.type === 'text' || block.type === 'code') {
                                addCanvasBlock(block.type, block.content);
                            }
                        });
                        showToast('تم إضافة المحتوى من الذكاء الاصطناعي.');
                    } else {
                        throw new Error("استجابة الذكاء الاصطناعي ليست بتنسيق JSON المتوقع.");
                    }

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        showToast(`خطأ في توليد الذكاء الاصطناعي للكانفاس: ${error.message}`);
                        console.error("Canvas AI Generation Error:", error);
                    } else {
                        showToast('تم إيقاف توليد الكانفاس.');
                    }
                } finally {
                    setLoadingState(false);
                }
            };


            // --- View Switching Logic ---
            /**
             * Switches the active view between chat and canvas.
             * @param {string} viewName - 'chat' or 'canvas'.
             */
            const switchView = (viewName) => {
                activeView = viewName;
                if (viewName === 'chat') {
                    allDOMElements.chatContainer.classList.add('active');
                    allDOMElements.canvasContainer.classList.remove('active');
                    allDOMElements.chatMessages.classList.add('active'); // Ensure chat messages are active
                    allDOMElements.chatForm.style.display = 'flex'; // Show chat input
                    allDOMElements.suggestionsContainer.style.display = conversations[currentConversationId]?.history.length > 2 ? 'none' : 'flex';
                    allDOMElements.toggleViewBtn.title = 'التبديل إلى لوحة الكانفاس';
                    allDOMElements.toggleViewBtn.innerHTML = `
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-columns">
                            <path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>
                        </svg>
                    `;
                } else { // viewName === 'canvas'
                    allDOMElements.chatContainer.classList.remove('active');
                    allDOMElements.canvasContainer.classList.add('active');
                    allDOMElements.chatMessages.classList.remove('active'); // Hide chat messages
                    allDOMElements.chatForm.style.display = 'none'; // Hide chat input
                    allDOMElements.suggestionsContainer.style.display = 'none'; // Hide suggestions in canvas view
                    allDOMElements.toggleViewBtn.title = 'التبديل إلى المحادثة';
                    allDOMElements.toggleViewBtn.innerHTML = `
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-message-square">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                    `;
                    if (!currentCanvasId) {
                        // If no canvas is loaded, create a new one automatically when switching to canvas view
                        createNewCanvas();
                    }
                }
                saveAllData(); // Save the active view state
                // Re-render lists to ensure active class is correct
                renderConversationList();
                renderCanvasList();
            };


            // --- Event Listeners ---

            // Form submission for sending messages (only in chat view)
            allDOMElements.chatForm.addEventListener('submit', (e) => {
                e.preventDefault(); // Prevent default form submission
                submitMessage(allDOMElements.promptInput.value.trim());
            });

            // Handle Enter key for sending messages and Shift+Enter for new line
            allDOMElements.promptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // Prevent new line on Enter
                    allDOMElements.chatForm.dispatchEvent(new Event('submit')); // Trigger form submit
                }
            });

            // Auto-resize textarea based on content
            allDOMElements.promptInput.addEventListener('input', () => {
                const el = allDOMElements.promptInput;
                el.style.height = 'auto'; // Reset height to recalculate
                el.style.height = (el.scrollHeight) + 'px'; // Set height based on scrollHeight
            });

            // New chat button in sidebar
            allDOMElements.newChatBtnSidebar.addEventListener('click', startNewChat);
            // New canvas button in sidebar
            allDOMElements.newCanvasBtnSidebar.addEventListener('click', createNewCanvas);

            // Toggle View Button
            allDOMElements.toggleViewBtn.addEventListener('click', () => {
                switchView(activeView === 'chat' ? 'canvas' : 'chat');
            });

            // -- Sidebar Toggle Logic for Responsiveness --
            allDOMElements.sidebarToggle.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent immediate closing due to global click listener
                allDOMElements.appLayout.classList.toggle('sidebar-open');
            });
            // Close sidebar when clicking on the mobile overlay
            allDOMElements.mobileOverlay.addEventListener('click', () => {
                allDOMElements.appLayout.classList.remove('sidebar-open');
            });

            // -- Message Actions Listener (Delegated) --
            // Use event delegation for message action buttons for efficiency
            allDOMElements.chatMessages.addEventListener('click', (e) => {
                const target = e.target.closest('.action-btn');
                if (!target) return; // Not an action button

                const messageElement = target.closest('.message');
                const contentDiv = messageElement.querySelector('.message-content');
                // Retrieve raw text from data attribute for actions
                const rawText = contentDiv.dataset.rawText;
                const messageId = messageElement.id; // Get message ID

                if (target.classList.contains('copy-btn')) {
                    copyToClipboard(rawText);
                } else if (target.classList.contains('regenerate-btn')) {
                    // Find the index of the message element in the DOM (excluding system message)
                    const allMessages = Array.from(allDOMElements.chatMessages.children);
                    const messageIndexInDOM = allMessages.indexOf(messageElement);

                    // Remove all subsequent messages from DOM
                    const messagesToRemove = allDOMElements.chatMessages.querySelectorAll(`.message:nth-child(n+${messageIndexInDOM + 1})`);
                    messagesToRemove.forEach(m => m.remove());
                    
                    // Remove corresponding messages from conversation history (adjust for system prompt offset)
                    // The history index needs to account for the system prompt that is always at index 0
                    // A user message at DOM index 0 is history index 1, AI message at DOM index 1 is history index 2 etc.
                    const historyIndex = messageIndexInDOM + 1; 
                    conversations[currentConversationId].history.splice(historyIndex);

                    fetchAiResponse(true); // Fetch a new response
                } else if (target.classList.contains('tts-btn')) {
                    speak(rawText, target);
                } else if (target.classList.contains('edit-btn')) {
                    handleEditMessage(messageElement, contentDiv, rawText);
                } else if (target.classList.contains('pin-btn')) { // Handle new pin button
                    const convId = target.dataset.conversationId;
                    togglePinMemory(messageId, convId, target);
                }
            });
            
            /**
             * Enables editing of a user message.
             * @param {HTMLElement} messageElement - The parent message div.
             * @param {HTMLElement} contentDiv - The div containing the message text.
             * @param {string} originalText - The original text of the message.
             */
            function handleEditMessage(messageElement, contentDiv, originalText) {
                contentDiv.setAttribute('contenteditable', 'true'); // Make content editable
                contentDiv.focus(); // Focus on the editable content

                const actionsWrapper = messageElement.querySelector('.message-actions');
                // Replace action buttons with save/cancel buttons
                actionsWrapper.innerHTML = `
                    <button class="action-btn save-edit-btn" title="حفظ وإرسال" type="button">✅</button>
                    <button class="action-btn cancel-edit-btn" title="إلغاء" type="button">❌</button>
                `;
                
                // Save and resend logic
                actionsWrapper.querySelector('.save-edit-btn').onclick = () => {
                    const newText = contentDiv.innerText.trim();
                    if (newText && newText !== originalText) {
                        // Determine the index of the message in the DOM (excluding system prompt)
                        const allUserMessagesInDOM = Array.from(allDOMElements.chatMessages.querySelectorAll('.user-message'));
                        const messageDomIndex = allUserMessagesInDOM.indexOf(messageElement);

                        // Remove all DOM elements from this user message onwards
                        let tempMessage = messageElement;
                        while(tempMessage) {
                            const nextSibling = tempMessage.nextElementSibling;
                            tempMessage.remove();
                            tempMessage = nextSibling;
                        }
                        
                        // Update history: find the correct user message in history and truncate from there.
                        let userMessageCount = 0;
                        let historyIndexToEdit = -1;
                        for(let i = 0; i < conversations[currentConversationId].history.length; i++) {
                            if (conversations[currentConversationId].history[i].role === 'user') {
                                if (userMessageCount === messageDomIndex) {
                                    historyIndexToEdit = i;
                                    break;
                                }
                                userMessageCount++;
                            }
                        }

                        if (historyIndexToEdit !== -1) {
                            conversations[currentConversationId].history.splice(historyIndexToEdit);
                            
                            // Update the content of the edited message
                            const updatedUserMessage = {
                                role: "user",
                                content: newText // Ensure content is string for OpenRouter
                            };

                            // Check if the original message had an image, re-attach it if so (OpenRouter specific)
                            const originalHistoryMessage = conversations[currentConversationId].history[historyIndexToEdit];
                            if (originalHistoryMessage && Array.isArray(originalHistoryMessage.content)) {
                                const originalImageContent = originalHistoryMessage.content.find(p => p.type === 'image_url');
                                if (originalImageContent) {
                                    updatedUserMessage.content = [
                                        { type: "text", text: newText },
                                        originalImageContent
                                    ];
                                }
                            }
                            
                            conversations[currentConversationId].history.push(updatedUserMessage);
                            
                            // Render the updated user message and then fetch AI response
                            createMessageElement('user', newText);
                            fetchAiResponse();
                        } else {
                            console.error("Could not find message in history for editing.");
                            // If somehow not found, just revert and show toast
                            showToast('فشل تعديل الرسالة.');
                        }
                    } else {
                         // If text is same or empty, just revert
                         contentDiv.innerHTML = marked.parse(originalText);
                         contentDiv.dataset.rawText = originalText;
                         showToast('لم يتم إجراء أي تغييرات.');
                    }
                    contentDiv.setAttribute('contenteditable', 'false');
                    restoreOriginalActions(actionsWrapper, messageElement.id); // Pass messageId to restore actions
                };

                // Cancel edit logic
                actionsWrapper.querySelector('.cancel-edit-btn').onclick = () => {
                    contentDiv.innerHTML = marked.parse(originalText); // Revert to original text
                    contentDiv.dataset.rawText = originalText;
                    contentDiv.setAttribute('contenteditable', 'false');
                    restoreOriginalActions(actionsWrapper, messageElement.id); // Pass messageId to restore actions
                };
            }

            /**
             * Restores the default action buttons (TTS, Copy, Regenerate, Edit, Pin) for a message.
             * @param {HTMLElement} actionsWrapper - The message-actions div.
             * @param {string} messageId - The ID of the message element.
             */
            function restoreOriginalActions(actionsWrapper, messageId) {
                const isAIMessage = actionsWrapper.closest('.ai-message');
                const isPinned = pinnedMemories.some(mem => mem.originalMessageId === messageId);

                actionsWrapper.innerHTML = `
                    ${isAIMessage ? `
                        <button class="action-btn tts-btn" title="قراءة النص" type="button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                        </button>
                        <button class="action-btn copy-btn" title="نسخ" type="button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                        </button>
                        <button class="action-btn regenerate-btn" title="إعادة توليد الإجابة" type="button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"></path><path d="M21 12A9 9 0 0 0 6 5.3L3 8"></path><path d="M21 22v-6h-6"></path><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"></path></svg>
                        </button>
                    ` : `
                        <button class="action-btn edit-btn" title="تعديل" type="button">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                        </button>
                    `}
                    <!-- Pin button is always available for all messages -->
                    <button class="action-btn pin-btn ${isPinned ? 'pinned' : ''}" title="${isPinned ? 'إلغاء التثبيت' : 'تثبيت الرسالة'}" type="button" data-message-id="${messageId}" data-conversation-id="${currentConversationId}">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-star">
                            <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                        </svg>
                    </button>
                `;
            }

            // -- Stop, Theme, Download Listeners --
            allDOMElements.stopGeneratingBtn.addEventListener('click', () => {
                abortController.abort(); // Signal to abort the fetch request
                setLoadingState(false); // Update UI
            });

            allDOMElements.themeToggleBtn.addEventListener('click', () => {
                document.body.classList.toggle('light-mode');
            });

            allDOMElements.downloadChatBtn.addEventListener('click', () => {
                if (!currentConversationId) {
                    showToast('لا توجد محادثة لتنزيلها.');
                    return;
                }
                let chatText = `محادثة Z Chat - ${new Date().toLocaleString('ar-SA')}\n\n`;
                // Iterate through history, skipping the system message
                conversations[currentConversationId].history.slice(1).forEach(msg => {
                    const prefix = msg.role === 'user' ? 'أنت: ' : 'Z Chat: ';
                    let content;
                    // Handle content that might be an array (text and image)
                    if (Array.isArray(msg.content)) {
                        content = msg.content.find(p => p.type === 'text')?.text || '[صورة مرفقة]';
                    } else {
                        content = msg.content;
                    }
                    chatText += `${prefix}${content}\n\n`;
                });
                const blob = new Blob([chatText], { type: 'text/plain;charset=utf-8' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `z-chat-${conversations[currentConversationId].title || currentConversationId}.txt`; // Use title or ID for filename
                a.click();
                URL.revokeObjectURL(a.href); // Clean up URL object
            });

            // -- Modals & Context Menu Listeners --
            allDOMElements.settingsBtn.addEventListener('click', () => allDOMElements.settingsModal.classList.add('visible'));

            // Close settings modal when clicking outside its content
            allDOMElements.settingsModal.addEventListener('click', (e) => {
                if (e.target === allDOMElements.settingsModal) {
                    allDOMElements.settingsModal.classList.remove('visible');
                }
            });

            // Save settings logic
            allDOMElements.saveSettingsBtn.addEventListener('click', () => {
                MODEL = allDOMElements.modelSelect.value;
                localStorage.setItem('z_chat_model', MODEL);
                initialSystemPrompt = allDOMElements.systemPromptTextarea.value;
                localStorage.setItem('z_chat_system_prompt', initialSystemPrompt);
                allDOMElements.settingsModal.classList.remove('visible');
                showToast('تم حفظ الإعدادات! ستبدأ محادثة جديدة لتطبيقها.');
                startNewChat(); // Apply new settings to a fresh chat
            });
            
            // Hide context menu on any click outside
            window.addEventListener('click', () => { 
                if (allDOMElements.contextMenu.style.display === 'block') {
                    allDOMElements.contextMenu.style.display = 'none';
                }
            });

            // Rename conversation from context menu
            allDOMElements.renameConvBtn.addEventListener('click', () => {
                const oldTitle = conversations[contextMenuTargetId].title;
                const newTitle = prompt("أدخل الاسم الجديد للمحادثة:", oldTitle);
                if (newTitle && newTitle.trim() !== oldTitle) {
                    conversations[contextMenuTargetId].title = newTitle.trim();
                    saveAllData();
                    renderConversationList();
                    showToast('تمت إعادة التسمية بنجاح.');
                }
            });
            
            // Delete conversation from context menu (with confirmation)
            allDOMElements.deleteConvBtn.addEventListener('click', () => {
                showConfirmModal(
                    'تأكيد الحذف',
                    `هل أنت متأكد من رغبتك في حذف محادثة "${conversations[contextMenuTargetId].title}"؟ لا يمكن التراجع عن هذا الإجراء.`,
                    () => {
                        delete conversations[contextMenuTargetId];
                        // If the deleted conversation was the currently active one, unset it
                        if (currentConversationId === contextMenuTargetId) {
                            currentConversationId = null;
                        }
                        // Also remove any pinned memories from this conversation
                        pinnedMemories = pinnedMemories.filter(mem => mem.originalConversationId !== contextMenuTargetId);
                        saveAllData();
                        loadAllData(); // Reload conversations to display updated list and pinned memories
                        showToast('تم حذف المحادثة.');
                    }
                );
            });

            /**
             * Displays a generic confirmation modal.
             * @param {string} title - The title of the confirmation modal.
             * @param {string} message - The message to display.
             * @param {Function} onConfirm - Callback function to execute if confirmed.
             */
            function showConfirmModal(title, message, onConfirm) {
                allDOMElements.confirmTitle.textContent = title;
                allDOMElements.confirmMessage.textContent = message;
                allDOMElements.confirmModal.classList.add('visible');

                // Using event listeners that are removed after use for single-fire actions
                const confirmHandler = () => {
                    onConfirm();
                    hideConfirmModal();
                    // Clean up listeners immediately to prevent multiple calls
                    allDOMElements.confirmOkBtn.removeEventListener('click', confirmHandler);
                    allDOMElements.confirmCancelBtn.removeEventListener('click', cancelHandler); 
                    allDOMElements.confirmModal.removeEventListener('click', overlayClickHandler);
                };
                const cancelHandler = () => {
                    hideConfirmModal();
                    // Clean up listeners
                    allDOMElements.confirmOkBtn.removeEventListener('click', confirmHandler);
                    allDOMElements.confirmCancelBtn.removeEventListener('click', cancelHandler);
                    allDOMElements.confirmModal.removeEventListener('click', overlayClickHandler);
                };
                const overlayClickHandler = (e) => {
                    if (e.target === allDOMElements.confirmModal) {
                        cancelHandler();
                    }
                };
                
                allDOMElements.confirmOkBtn.addEventListener('click', confirmHandler, { once: true });
                allDOMElements.confirmCancelBtn.addEventListener('click', cancelHandler, { once: true });
                allDOMElements.confirmModal.addEventListener('click', overlayClickHandler, { once: true });
            }

            /**
             * Hides the confirmation modal.
             */
            function hideConfirmModal() {
                allDOMElements.confirmModal.classList.remove('visible');
            }

            // -- Image Handling (Attachment & Drag/Drop) --
            allDOMElements.attachmentBtn.addEventListener('click', () => allDOMElements.imageUploadInput.click());
            allDOMElements.imageUploadInput.addEventListener('change', (e) => handleFileSelect(e.target.files));

            // Drag and drop event listeners
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                allDOMElements.chatContainer.addEventListener(eventName, (e) => {
                    e.preventDefault(); 
                    e.stopPropagation(); 
                }, false); 
            });

            // Show drag overlay on drag enter/over
            ['dragenter', 'dragover'].forEach(eventName => {
                allDOMElements.chatContainer.addEventListener(eventName, () => allDOMElements.dragDropOverlay.classList.add('visible'));
            });

            // Hide drag overlay on drag leave/drop
            ['dragleave', 'drop'].forEach(eventName => {
                allDOMElements.chatContainer.addEventListener(eventName, () => allDOMElements.dragDropOverlay.classList.remove('visible'));
            });

            // Handle file drop
            allDOMElements.chatContainer.addEventListener('drop', (e) => handleFileSelect(e.dataTransfer.files));

            /**
             * Handles selected files (from input or drag-and-drop).
             * @param {FileList} files - The FileList object containing selected files.
             */
            function handleFileSelect(files) {
                if (files && files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            attachedImage = event.target.result; 
                            displayImagePreview(attachedImage);
                        };
                        reader.readAsDataURL(file); 
                    } else {
                        showToast('الرجاء اختيار ملف صورة فقط.');
                    }
                }
            }

            /**
             * Displays a preview of the attached image.
             * @param {string} imageDataUrl - The base64 URL of the image.
             */
            function displayImagePreview(imageDataUrl) {
                allDOMElements.imagePreviewContainer.style.display = 'block';
                allDOMElements.imagePreviewContainer.innerHTML = `
                    <div class="image-preview">
                        <img src="${imageDataUrl}" alt="معاينة الصورة المرفقة"/>
                        <button class="remove-image-btn" type="button" onclick="window.clearImagePreview()">×</button>
                    </div>
                `;
                allDOMElements.promptInput.focus(); 
            }

            /**
             * Clears the attached image and its preview.
             * Made global so it can be called from inline onclick.
             */
            window.clearImagePreview = () => {
                attachedImage = null;
                allDOMElements.imageUploadInput.value = ''; 
                allDOMElements.imagePreviewContainer.style.display = 'none';
                allDOMElements.imagePreviewContainer.innerHTML = '';
            };

            // --- Canvas Toolbar Event Listeners ---
            allDOMElements.addTextBlockBtn.addEventListener('click', () => addCanvasBlock('text'));
            allDOMElements.addCodeBlockBtn.addEventListener('click', () => addCanvasBlock('code'));
            allDOMElements.addImageBlockBtn.addEventListener('click', () => addCanvasBlock('image'));
            allDOMElements.askAiCanvasBtn.addEventListener('click', askAiForCanvasContent);
            allDOMElements.renameCanvasBtn.addEventListener('click', renameCurrentCanvas);
            allDOMElements.deleteCanvasBtn.addEventListener('click', deleteCurrentCanvas);


            // --- Initial Load ---
            loadAllData();
        });
    </script>
</body>
</html>
